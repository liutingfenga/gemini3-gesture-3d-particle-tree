<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Merry Christmas</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <script type="importmap">
        {
            "imports": {
                "three": "./js/three/three.module.js",
                "three/addons/": "./js/three/jsm/",
                "@mediapipe/tasks-vision": "./js/mediapipe/tasks-vision.js"
            }
        }
    </script>
</head>

<body>

    <div id="loader" style="display: none;">
        <div class="enter-content">
            <div class="enter-title">Merry Christmas</div>
            <button id="enter-btn" class="enter-btn">å¼€å¯åœ£è¯æ ‘</button>
        </div>
        <div class="loading-content">
            <div class="spinner"></div>
            <div class="loader-text">Loading...</div>
        </div>
    </div>

    <div id="toast"></div>
    <div id="canvas-container"></div>

    <!-- æ‰‹åŠ¿æ¨¡å‹åŠ è½½æç¤º -->
    <div id="gesture-loading-tip"
        style="display:none; position:fixed; left:50%; bottom:5%; transform:translateX(-50%); z-index:1000; background:rgba(0,0,0,0.8); color:#ffcc00; padding:15px 30px; border-radius:10px; font-size:18px; font-weight:bold; text-align:center; box-shadow:0 4px 20px rgba(255,204,0,0.3); animation:pulse 1.5s ease-in-out infinite;">
        â›³ åŠ è½½æ‰‹åŠ¿æ“æ§æ¨¡å‹ä¸­...<span id="gesture-countdown">30</span>ç§’
    </div>

    <audio id="bg-music" loop style="display:none;"></audio>

    <!-- å‘Šç™½ä¿¡å¼¹çª— -->
    <div id="confession-overlay" class="confession-overlay" style="display:none;">
        <div class="envelope-wrapper">
            <div class="envelope" id="envelope">
                <div class="envelope-back"></div>
                <div class="letter">
                    <button id="confession-close" class="confession-close">âœ•</button>
                    <div class="letter-inner">
                        <div class="confession-content" id="confession-text"></div>
                    </div>
                    <div class="letter-decoration deco-tl">â„ï¸</div>
                    <div class="letter-decoration deco-tr">ğŸ„</div>
                    <div class="letter-decoration deco-bl">ğŸ¦Œ</div>
                    <div class="letter-decoration deco-br">ğŸ</div>
                </div>
                <div class="envelope-front"></div>
                <div class="envelope-flap"></div>
                <div class="envelope-seal" id="envelope-seal">
                    <span class="seal-content">âœ¨</span>
                </div>
            </div>
        </div>
    </div>

    <!-- å‘Šç™½ä¿¡ç®¡ç†é¢æ¿ -->
    <div id="confession-manager" class="confession-manager panel-draggable">
        <div class="confession-manager-header panel-header">
            <span class="confession-manager-title">ğŸ’Œ å‘Šç™½ä¿¡ç®¡ç†</span>
            <div class="panel-actions">
                <button class="panel-action-btn panel-maximize-btn" title="æ”¾å¤§/ç¼©å°">â›¶</button>
                <button id="confession-manager-close" class="confession-manager-close">âœ•</button>
            </div>
        </div>
        <div class="confession-input-group">
            <label class="confession-input-label">ä¿¡ä»¶å†…å®¹</label>
            <textarea id="confession-input" class="confession-textarea" placeholder="åœ¨è¿™é‡Œè¾“å…¥ä½ æƒ³è¯´çš„è¯..."></textarea>
        </div>
        <div class="confession-buttons">
            <button id="preview-confession-btn" class="apply-btn" style="flex: 1; background: #ff4081;">ğŸ’Œ é¢„è§ˆæ•ˆæœ</button>
            <button id="save-confession-btn" class="apply-btn" style="flex: 1;">âœ… ä¿å­˜å†…å®¹</button>
        </div>
        <div class="panel-resize-handle"></div>
    </div>

    <div id="ui-layer">
        <div id="ui-content">
            <h1>Merry Christmas</h1>

            <!-- æ‰‹åŠ¿æ“ä½œæç¤ºæ¡† -->
            <div id="instruction-box" class="instruction-box panel-draggable">
                <div class="instruction-header panel-header">
                    <span>ğŸ–ï¸ æ‰‹åŠ¿æ“ä½œæŒ‡å—</span>
                    <button id="instruction-close" class="instruction-close">âœ•</button>
                </div>
                <div class="instruction-content">
                    <div class="instruction-item">
                        <span class="instruction-icon">ğŸ–ï¸</span>
                        <div class="instruction-text">
                            <strong>å¼ å¼€æ‰‹æŒ</strong>
                            <span>æ§åˆ¶æ—‹è½¬è§†è§’</span>
                        </div>
                    </div>
                    <div class="instruction-item">
                        <span class="instruction-icon">ğŸ‘Š</span>
                        <div class="instruction-text">
                            <strong>æ¡ç´§æ‹³å¤´</strong>
                            <span>è¿˜åŸåœ£è¯æ ‘å½¢æ€</span>
                        </div>
                    </div>
                    <div class="instruction-item">
                        <span class="instruction-icon">ğŸ‘Œ</span>
                        <div class="instruction-text">
                            <strong>æåˆæ‰‹æŒ‡</strong>
                            <span>é€‰ä¸­å¹¶æ”¾å¤§ç…§ç‰‡</span>
                        </div>
                    </div>
                    <div class="instruction-item">
                        <span class="instruction-icon">â¤ï¸</span>
                        <div class="instruction-text">
                            <strong>åŒæ‰‹æ¯”å¿ƒ</strong>
                            <span>è§¦å‘æµªæ¼«å‘Šç™½ä¿¡æ¨¡å¼</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="menu-container">
                <button id="main-menu-btn" class="main-menu-btn">âš™ï¸</button>

                <div id="menu-items" class="menu-items">
                    <button id="help-btn" class="btn-style">â“ å¸®åŠ©</button>
                    <button id="menu-music-toggle-btn" class="btn-style">â–¶ï¸ æ’­æ”¾éŸ³ä¹</button>
                    <button id="camera-btn" class="btn-style">ğŸ–ï¸ å¼€å¯æ‰‹åŠ¿</button>
                    <button id="music-manage-btn" class="btn-style">ğŸµ éŸ³ä¹ç®¡ç†</button>
                    <button id="photo-manage-btn" class="btn-style">ğŸ“· å›¾ç‰‡ç®¡ç†</button>
                    <button id="confession-manage-btn" class="btn-style">ğŸ’Œ å‘Šç™½ä¿¡ç®¡ç†</button>

                    <button id="preview-toggle-btn" class="btn-style">ğŸ–¼ï¸ éšè—æ‘„åƒå¤´æ¡†</button>
                    <button id="toggle-ui-btn" class="btn-style">ğŸ‘ï¸ éšè—æ‰€æœ‰UIå…ƒç´ (åªæœ‰åœ£è¯æ ‘)</button>
                    <button id="gesture-tip-btn" class="btn-style"
                        style="cursor: default; opacity: 0.7;">æ‰‹åŠ¿æ— æ•ˆæ—¶è¯·ç”¨æ‰‹æŒè´´è¿‘æ‘„åƒå¤´ç„¶åæ‹‰è¿œå†è¯•</button>
                    <!-- æ›´å¤šåŠŸèƒ½ä¸‹æ‹‰èœå• -->
                    <div class="more-functions-container">
                        <button id="more-functions-btn" class="btn-style">ğŸ”§ æ›´å¤šåŠŸèƒ½</button>
                        <div id="more-functions-menu" class="more-functions-menu">
                            <button id="title-settings-btn" class="btn-style">ğŸ·ï¸ æ ‡é¢˜è®¾ç½®</button>
                            <button id="bg-manage-btn" class="btn-style">ğŸŒŒ èƒŒæ™¯è®¾ç½®</button>
                            <button id="particle-settings-btn" class="btn-style">âœ¨ ç²’å­è®¾ç½®</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ç²’å­è®¾ç½®é¢æ¿ -->
    <div id="particle-settings" class="particle-settings panel-draggable">
        <div class="particle-settings-header panel-header">
            <span class="particle-settings-title">âœ¨ ç²’å­æ•°é‡è®¾ç½®</span>
            <div class="panel-actions">
                <button class="panel-action-btn panel-maximize-btn" title="æ”¾å¤§/ç¼©å°">â›¶</button>
                <button id="particle-settings-close" class="particle-settings-close">âœ•</button>
            </div>
        </div>
        <div class="device-hint" id="device-hint">å½“å‰è®¾å¤‡: PCç«¯</div>
        <div class="slider-group">
            <div class="slider-label">
                <span>ğŸ„ è£…é¥°ç²’å­</span>
                <span class="slider-value" id="particle-value">1500</span>
            </div>
            <input type="range" class="slider-input" id="particle-slider" min="100" max="3000" value="1500">
        </div>
        <div class="slider-group">
            <div class="slider-label">
                <span>âœ¨ é£˜æµ®å…‰ç‚¹</span>
                <span class="slider-value" id="dust-value">2500</span>
            </div>
            <input type="range" class="slider-input" id="dust-slider" min="0" max="5000" value="2500">
        </div>
        <div style="display: flex; gap: 10px;">
            <button id="reset-particle-btn" class="apply-btn"
                style="flex: 1; background: rgba(100,100,100,0.3); border-color: rgba(150,150,150,0.5); color: #aaa;">ğŸ”„
                æ¢å¤é»˜è®¤</button>
            <button id="apply-particle-btn" class="apply-btn" style="flex: 1;">âœ… åº”ç”¨è®¾ç½®</button>
        </div>
        <div class="panel-resize-handle"></div>
    </div>

    <!-- å›¾ç‰‡ç®¡ç†é¢æ¿ -->
    <div id="photo-manager" class="photo-manager panel-draggable">
        <div class="photo-manager-header panel-header">
            <span class="photo-manager-title">ğŸ“· å›¾ç‰‡ç®¡ç† <span id="photo-count" class="photo-count">(0å¼ )</span></span>
            <div class="panel-actions">
                <button id="clear-photos-btn" class="panel-action-btn" title="æ¸…ç©ºæ‰€æœ‰ç…§ç‰‡">ğŸ—‘ï¸</button>
                <button class="panel-action-btn panel-maximize-btn" title="æ”¾å¤§/ç¼©å°">â›¶</button>
                <button id="photo-manager-close" class="photo-manager-close">âœ•</button>
            </div>
        </div>
        <div id="photo-grid" class="photo-grid">
            <!-- å›¾ç‰‡åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
        </div>
        <input type="file" id="file-input" multiple accept="image/*" style="display:none;">
        <div class="panel-resize-handle"></div>
    </div>

    <!-- éŸ³ä¹ç®¡ç†é¢æ¿ -->
    <div id="music-manager" class="music-manager panel-draggable">
        <div class="music-manager-header panel-header">
            <span class="music-manager-title">ğŸµ éŸ³ä¹ç®¡ç†</span>
            <div class="panel-actions">
                <button class="panel-action-btn panel-maximize-btn" title="æ”¾å¤§/ç¼©å°">â›¶</button>
                <button id="music-manager-close" class="music-manager-close">âœ•</button>
            </div>
        </div>
        <div class="music-content">
            <div class="music-current">
                <span class="music-icon">ğŸ¶</span>
                <div class="music-info">
                    <div class="music-name" id="current-music-name">é»˜è®¤éŸ³ä¹</div>
                    <div class="music-status" id="music-status">æœªæ’­æ”¾</div>
                </div>
            </div>
            <div class="music-actions">
                <button id="play-pause-btn" class="music-btn">
                    <span class="music-btn-icon">â–¶ï¸</span>
                    <span>æ’­æ”¾</span>
                </button>
                <label class="music-btn music-upload-label">
                    <span class="music-btn-icon">ğŸ“</span>
                    <span>æ›´æ¢éŸ³ä¹</span>
                    <input type="file" id="music-input" accept="audio/*, video/mp4">
                </label>
                <button id="clear-music-btn" class="music-btn music-btn-danger">
                    <span class="music-btn-icon">ğŸ”„</span>
                    <span>é‡ç½®</span>
                </button>
            </div>
        </div>
        <div class="panel-resize-handle"></div>
    </div>

    <!-- æ ‡é¢˜è®¾ç½®é¢æ¿ -->
    <div id="title-settings" class="title-settings panel-draggable">
        <div class="title-settings-header panel-header">
            <span class="title-settings-title">ğŸ·ï¸ æ ‡é¢˜è®¾ç½®</span>
            <div class="panel-actions">
                <button class="panel-action-btn panel-maximize-btn" title="æ”¾å¤§/ç¼©å°">â›¶</button>
                <button id="title-settings-close" class="title-settings-close">âœ•</button>
            </div>
        </div>
        <div class="title-input-group">
            <label class="title-input-label">ä¸»æ ‡é¢˜æ–‡å­—</label>
            <input type="text" id="main-title-input" class="title-input" placeholder="è¾“å…¥ä¸»æ ‡é¢˜..." maxlength="30">
        </div>
        <div class="title-input-group">
            <label class="title-input-label">å¼•å¯¼é¡µæ ‡é¢˜</label>
            <input type="text" id="enter-title-input" class="title-input" placeholder="è¾“å…¥å¼•å¯¼é¡µæ ‡é¢˜..." maxlength="30">
        </div>
        <div class="title-buttons">
            <button id="reset-title-btn" class="apply-btn"
                style="flex: 1; background: rgba(100,100,100,0.3); border-color: rgba(150,150,150,0.5); color: #aaa;">ğŸ”„
                æ¢å¤é»˜è®¤</button>
            <button id="apply-title-btn" class="apply-btn" style="flex: 1;">âœ… åº”ç”¨</button>
        </div>
        <div class="panel-resize-handle"></div>
    </div>

    <!-- èƒŒæ™¯è®¾ç½®é¢æ¿ -->
    <div id="bg-manager" class="bg-manager panel-draggable">
        <div class="bg-manager-header panel-header">
            <span class="bg-manager-title">ğŸŒŒ èƒŒæ™¯è®¾ç½®</span>
            <div class="panel-actions">
                <button class="panel-action-btn panel-maximize-btn" title="æ”¾å¤§/ç¼©å°">â›¶</button>
                <button id="bg-manager-close" class="bg-manager-close">âœ•</button>
            </div>
        </div>
        <div class="bg-content">
            <div class="bg-preview-container">
                <div class="bg-preview" id="bg-preview">
                    <span class="bg-preview-text">é»˜è®¤é»‘è‰²èƒŒæ™¯</span>
                </div>
            </div>
            <div class="bg-actions">
                <label class="bg-btn bg-upload-label">
                    <span class="bg-btn-icon">ğŸ“·</span>
                    <span>ä¸Šä¼ å›¾ç‰‡</span>
                    <input type="file" id="bg-input" accept="image/*">
                </label>
                <button id="reset-bg-btn" class="bg-btn bg-btn-danger">
                    <span class="bg-btn-icon">ğŸ”„</span>
                    <span>æ¢å¤é»˜è®¤</span>
                </button>
            </div>
        </div>
        <div class="panel-resize-handle"></div>
    </div>

    

    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline muted style="display:none;"></video>
        <canvas id="webcam-preview"></canvas>
        <div id="gesture-status">è¯·ç‚¹å‡»"å¼€å¯æ‰‹åŠ¿"æŒ‰é’®</div>
        <button id="request-camera-btn"
            style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(76,175,80,0.9); color:#fff; border:none; border-radius:8px; padding:10px 15px; font-size:12px; cursor:pointer; z-index:10; white-space:nowrap; pointer-events:auto;">ğŸ“·
            è¯·æ±‚æ‘„åƒå¤´æƒé™</button>
    </div>

    

    <!-- æ³¨å†Œ Service Worker ä»¥ç¼“å­˜å¤§å‹èµ„æºæ–‡ä»¶ -->
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./js/sw.js').then(function (registration) {
                console.log('[App] Service Worker æ³¨å†ŒæˆåŠŸ, scope:', registration.scope);
            }).catch(function (err) {
                console.warn('[App] Service Worker æ³¨å†Œå¤±è´¥:', err);
            });
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        const isMobile = window.innerWidth < 768;
        const DEFAULT_MUSIC_URL = "./assets/shengdanbgm.mp3";

        // ä» localStorage è¯»å–ç²’å­è®¾ç½®
        const PARTICLE_SETTINGS_KEY = 'xmas_particle_settings';
        function getParticleSettings() {
            const saved = localStorage.getItem(PARTICLE_SETTINGS_KEY);
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) { }
            }
            // é»˜è®¤å€¼
            return {
                count: isMobile ? 500 : 1500,
                dustCount: isMobile ? 600 : 2500
            };
        }
        const particleSettings = getParticleSettings();

        const CONFIG = {
            colors: { bg: 0x000000, champagneGold: 0xffd966, deepGreen: 0x03180a, accentRed: 0x990000 },
            particles: { count: particleSettings.count, dustCount: particleSettings.dustCount, treeHeight: 24, treeRadius: 8 },
            camera: { z: 50 }
        };

        const STATE = { mode: 'TREE', focusTarget: null, hand: { detected: false, x: 0, y: 0, lastX: 0, lastY: 0, smoothX: 0, smoothY: 0, isGrabbing: false }, rotation: { x: 0, y: 0, targetX: 0, targetY: 0 }, uiVisible: true };

        // æ‰‹åŠ¿æ§åˆ¶å¹³æ»‘å‚æ•°
        const GESTURE_CONFIG = {
            smoothFactor: 0.3,      // æ‰‹éƒ¨ä½ç½®å¹³æ»‘ç³»æ•°ï¼ˆè¶Šå°è¶Šå¹³æ»‘ï¼Œ0.1-0.5ï¼‰
            deadZone: 0.008,        // æ­»åŒºé˜ˆå€¼ï¼Œå¿½ç•¥å¾®å°æ™ƒåŠ¨
            rotationSmooth: 0.15,   // æ—‹è½¬å¹³æ»‘ç³»æ•°
            sensitivity: 1.8        // æ—‹è½¬çµæ•åº¦
        };
        let scene, camera, renderer, composer, controls, mainGroup;
        let clock = new THREE.Clock();
        let particleSystem = [];  // å­˜å‚¨ç…§ç‰‡ç²’å­
        let photoMeshGroup = new THREE.Group();
        let handLandmarker, video, webcamCanvas, webcamCtx;
        let caneTexture;
        let isPreviewVisible = true;
        let uploadedPhotos = []; // å­˜å‚¨å·²ä¸Šä¼ ç…§ç‰‡çš„ base64 æ•°æ® (å…¨å±€å˜é‡)

        // InstancedMesh ä¼˜åŒ–ç›¸å…³
        let instancedMeshes = {};  // å­˜å‚¨å„ç±»å‹çš„ InstancedMesh
        let particleData = [];     // å­˜å‚¨æ‰€æœ‰ç²’å­çš„æ•°æ®ï¼ˆä½ç½®ã€æ—‹è½¬ã€ç¼©æ”¾ç­‰ï¼‰
        let dustInstancedMesh = null;  // ç°å°˜ç²’å­ InstancedMesh
        let dustData = [];         // ç°å°˜ç²’å­æ•°æ®
        
        // é›ªèŠ±ç³»ç»Ÿ
        let snowInstancedMesh = null;
        let snowData = [];
        let isSnowing = true; // é»˜è®¤ä¸‹é›ª

        const dummy = new THREE.Object3D();  // ç”¨äºè®¡ç®—çŸ©é˜µ

        // åˆ†å¸§æ›´æ–°ä¼˜åŒ–ï¼ˆæ¯å¸§æ›´æ–°å…¨éƒ¨ï¼Œä½†ä¼˜åŒ–è®¡ç®—ï¼‰
        let particleUpdateIndex = 0;
        let dustUpdateIndex = 0;
        // æ¯å¸§æ›´æ–°æ‰€æœ‰ç²’å­ï¼Œä¿è¯æµç•…æ€§
        const PARTICLES_PER_FRAME = CONFIG.particles.count;
        const DUST_PER_FRAME = CONFIG.particles.dustCount;

        // --- IndexedDB ---
        const DB_NAME = 'XmasTreeDB_V4';
        const STORE_PHOTOS = 'photos';
        const STORE_MUSIC = 'music';
        const STORE_BACKGROUND = 'background';
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 2);
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_PHOTOS)) db.createObjectStore(STORE_PHOTOS, { autoIncrement: true });
                    if (!db.objectStoreNames.contains(STORE_MUSIC)) db.createObjectStore(STORE_MUSIC, { keyPath: 'id' });
                    if (!db.objectStoreNames.contains(STORE_BACKGROUND)) db.createObjectStore(STORE_BACKGROUND, { keyPath: 'id' });
                };
                request.onsuccess = (event) => { db = event.target.result; resolve(db); };
                request.onerror = (event) => { console.warn('IndexedDB åˆå§‹åŒ–å¤±è´¥:', event.target.error); reject(event); };
            });
        }

        async function savePhotoToDB(base64Data) {
            if (!db) return;
            try {
                const tx = db.transaction([STORE_PHOTOS], 'readwrite');
                tx.objectStore(STORE_PHOTOS).add(base64Data);
                tx.onerror = () => console.warn('ç…§ç‰‡ä¿å­˜å¤±è´¥');
            } catch (e) {
                console.warn('ç…§ç‰‡ä¿å­˜å¼‚å¸¸:', e);
            }
        }

        async function saveMusicToDB(file) {
            if (!db) return;
            try {
                const tx = db.transaction([STORE_MUSIC], 'readwrite');
                tx.objectStore(STORE_MUSIC).put({ id: 'bgm', file: file });
                tx.onerror = () => console.warn('éŸ³ä¹ä¿å­˜å¤±è´¥');
            } catch (e) {
                console.warn('éŸ³ä¹ä¿å­˜å¼‚å¸¸:', e);
            }
        }

        async function saveBackgroundToDB(base64Data) {
            if (!db) return;
            try {
                const tx = db.transaction([STORE_BACKGROUND], 'readwrite');
                tx.objectStore(STORE_BACKGROUND).put({ id: 'bg', data: base64Data });
                tx.onerror = () => console.warn('èƒŒæ™¯ä¿å­˜å¤±è´¥');
            } catch (e) {
                console.warn('èƒŒæ™¯ä¿å­˜å¼‚å¸¸:', e);
            }
        }

        async function clearBackgroundData() {
            if (!db) return;
            const tx = db.transaction([STORE_BACKGROUND], 'readwrite');
            tx.objectStore(STORE_BACKGROUND).clear();
            tx.oncomplete = () => {
                // æ¢å¤é»˜è®¤é»‘è‰²èƒŒæ™¯
                scene.background = new THREE.Color(CONFIG.colors.bg);
                updateBgPreview(null);
                showToast("ğŸŒŒ å·²æ¢å¤é»˜è®¤èƒŒæ™¯");
            };
        }

        async function loadDataFromDB() {
            if (!db) return;
            // Photos
            const photoTx = db.transaction([STORE_PHOTOS], 'readonly');
            const photoReq = photoTx.objectStore(STORE_PHOTOS).getAll();
            photoReq.onsuccess = () => {
                const photos = photoReq.result;
                if (photos && photos.length > 0) {
                    showToast(`å·²æ¢å¤ ${photos.length} å¼ ç…§ç‰‡`);
                    // åŒæ­¥åˆ° uploadedPhotos æ•°ç»„
                    if (typeof uploadedPhotos !== 'undefined') {
                        uploadedPhotos.push(...photos);
                    }
                    photos.forEach(base64 => {
                        new THREE.TextureLoader().load(
                            base64,
                            (t) => { t.colorSpace = THREE.SRGBColorSpace; addPhotoToScene(t); },
                            undefined,
                            (err) => { console.warn('ç…§ç‰‡çº¹ç†åŠ è½½å¤±è´¥:', err); }
                        );
                    });
                }
            };
            // Music
            const musicTx = db.transaction([STORE_MUSIC], 'readonly');
            const musicReq = musicTx.objectStore(STORE_MUSIC).get('bgm');
            musicReq.onsuccess = () => {
                if (musicReq.result && musicReq.result.file) {
                    playMusic(musicReq.result.file);
                    showToast("å·²åŠ è½½è‡ªå®šä¹‰éŸ³ä¹");
                } else {
                    playDefaultMusic();
                }
            };
            // Background
            try {
                const bgTx = db.transaction([STORE_BACKGROUND], 'readonly');
                const bgReq = bgTx.objectStore(STORE_BACKGROUND).get('bg');
                bgReq.onsuccess = () => {
                    if (bgReq.result && bgReq.result.data) {
                        applyBackgroundImage(bgReq.result.data);
                        updateBgPreview(bgReq.result.data);
                    }
                };
            } catch (e) {
                // èƒŒæ™¯å­˜å‚¨ä¸å­˜åœ¨ï¼Œå¿½ç•¥
            }
        }

        // åº”ç”¨èƒŒæ™¯å›¾ç‰‡
        function applyBackgroundImage(base64Data) {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(base64Data, (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                scene.background = texture;
            });
        }

        // æ›´æ–°èƒŒæ™¯é¢„è§ˆ
        function updateBgPreview(base64Data) {
            const bgPreview = document.getElementById('bg-preview');
            if (!bgPreview) return;
            bgPreview.innerHTML = '';
            if (base64Data) {
                const img = document.createElement('img');
                img.src = base64Data;
                img.alt = "å½“å‰èƒŒæ™¯";
                bgPreview.appendChild(img);
            } else {
                const span = document.createElement('span');
                span.className = 'bg-preview-text';
                span.textContent = 'é»˜è®¤é»‘è‰²èƒŒæ™¯';
                bgPreview.appendChild(span);
            }
        }

        async function clearPhotoData() {
            if (!db) return;
            const tx = db.transaction([STORE_PHOTOS], 'readwrite');
            tx.objectStore(STORE_PHOTOS).clear();
        }

        async function clearMusicData() {
            if (!db) return;
            const tx = db.transaction([STORE_MUSIC], 'readwrite');
            tx.objectStore(STORE_MUSIC).clear();
            tx.oncomplete = () => {
                localStorage.removeItem(MUSIC_STATE_KEY); // æ¸…é™¤æš‚åœçŠ¶æ€ï¼Œæ¢å¤é»˜è®¤æ’­æ”¾
                playDefaultMusic();
                showToast("ğŸµ å·²æ¢å¤é»˜è®¤éŸ³ä¹");
            };
        }

        // --- Music Logic ---
        const bgAudio = document.getElementById('bg-music');
        const playPauseBtn = document.getElementById('play-pause-btn');
        let isMusicPlaying = false;
        const MUSIC_STATE_KEY = 'musicPlayingState'; // ä¿å­˜éŸ³ä¹æ’­æ”¾çŠ¶æ€çš„key
        let currentMusicObjectURL = null; // è·Ÿè¸ªå½“å‰çš„ ObjectURL ä»¥ä¾¿é‡Šæ”¾

        function playMusic(source) {
            // é‡Šæ”¾ä¹‹å‰çš„ ObjectURL é˜²æ­¢å†…å­˜æ³„æ¼
            if (currentMusicObjectURL) {
                URL.revokeObjectURL(currentMusicObjectURL);
                currentMusicObjectURL = null;
            }

            if (source instanceof Blob || source instanceof File) {
                currentMusicObjectURL = URL.createObjectURL(source);
                bgAudio.src = currentMusicObjectURL;
            } else {
                bgAudio.src = source;
            }
            bgAudio.volume = 0.5;
            attemptPlay();
        }

        function playDefaultMusic() {
            bgAudio.src = DEFAULT_MUSIC_URL;
            bgAudio.volume = 0.5;
            attemptPlay();
        }

        function attemptPlay() {
            // æ£€æŸ¥ç”¨æˆ·ä¹‹å‰æ˜¯å¦æ‰‹åŠ¨æš‚åœäº†éŸ³ä¹
            const savedState = localStorage.getItem(MUSIC_STATE_KEY);
            // å¦‚æœç”¨æˆ·æ˜ç¡®æš‚åœäº†ï¼Œåˆ™ä¸è‡ªåŠ¨æ’­æ”¾
            if (savedState === 'paused') {
                updatePlayBtn(false);
                return;
            }
            const p = bgAudio.play();
            if (p !== undefined) {
                p.then(() => {
                    updatePlayBtn(true);
                    localStorage.setItem(MUSIC_STATE_KEY, 'playing');
                }).catch(() => {
                    updatePlayBtn(false);
                });
            }
        }

        function updatePlayBtn(playing) {
            isMusicPlaying = playing;
            const playPauseBtnIcon = playPauseBtn.querySelector('.music-btn-icon');
            const playPauseBtnText = playPauseBtn.querySelector('span:last-child');
            if (playPauseBtnIcon && playPauseBtnText) {
                playPauseBtnIcon.textContent = playing ? "â¸ï¸" : "â–¶ï¸";
                playPauseBtnText.textContent = playing ? "æš‚åœ" : "æ’­æ”¾";
            }
            playPauseBtn.classList.toggle("active", playing);
            // æ›´æ–°éŸ³ä¹çŠ¶æ€æ˜¾ç¤º
            const musicStatus = document.getElementById('music-status');
            if (musicStatus) {
                musicStatus.textContent = playing ? "æ­£åœ¨æ’­æ”¾" : "å·²æš‚åœ";
            }
        }

        playPauseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (isMusicPlaying) {
                bgAudio.pause();
                updatePlayBtn(false);
                localStorage.setItem(MUSIC_STATE_KEY, 'paused'); // ç”¨æˆ·æ‰‹åŠ¨æš‚åœ
            } else {
                bgAudio.play();
                updatePlayBtn(true);
                localStorage.setItem(MUSIC_STATE_KEY, 'playing'); // ç”¨æˆ·æ‰‹åŠ¨æ’­æ”¾
            }
        });

        // --- Init ---
        async function init() {
            try { await initDB(); } catch (e) { }
            initThree(); setupEnvironment(); setupLights(); createTextures(); createParticles(); createDust(); createSnow(); createDefaultPhotos(); setupPostProcessing(); setupEvents(); setupUI();

            loadDataFromDB();

            const loader = document.getElementById('loader');
            animate();
            setTimeout(() => {
                if (loader) loader.style.opacity = 0;
                setTimeout(() => loader?.remove(), 800);
            }, 500);

            if (handLandmarker) {
                document.getElementById('gesture-status').innerText = 'æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...';
            } else {
                document.getElementById('gesture-status').innerText = 'æ­£åœ¨åŠ è½½æ‰‹åŠ¿æ“æ§æ¨¡å‹...';
            }
            enableHandTracking(true);
        }

        function updatePhotoCount() {
            const photoCountSpan = document.getElementById('photo-count');
            if (photoCountSpan) {
                photoCountSpan.textContent = `(${uploadedPhotos.length}å¼ )`;
            }
        }

        // æ¸²æŸ“å›¾ç‰‡ç½‘æ ¼
        function renderPhotoGrid() {
            const photoGrid = document.getElementById('photo-grid');
            const photoCountSpan = document.getElementById('photo-count');
            if (!photoGrid) return;

            photoGrid.innerHTML = '';

            // æ·»åŠ ä¸Šä¼ æŒ‰é’®
            const addBtn = document.createElement('label');
            addBtn.className = 'photo-add-btn';
            addBtn.innerHTML = '<span>+</span><small>æ·»åŠ </small>';
            addBtn.setAttribute('for', 'file-input');
            photoGrid.appendChild(addBtn);

            if (uploadedPhotos.length === 0) {
                const emptyTip = document.createElement('div');
                emptyTip.className = 'photo-empty';
                emptyTip.textContent = 'æš‚æ— ç…§ç‰‡ï¼Œç‚¹å‡» + æ·»åŠ ';
                photoGrid.appendChild(emptyTip);
            } else {
                uploadedPhotos.forEach((base64, index) => {
                    const item = document.createElement('div');
                    item.className = 'photo-item';

                    const img = document.createElement('img');
                    img.src = base64;
                    img.alt = `ç…§ç‰‡ ${index + 1}`;

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'photo-item-delete';
                    deleteBtn.innerHTML = 'âœ•';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deletePhoto(index);
                    };

                    item.appendChild(img);
                    item.appendChild(deleteBtn);
                    photoGrid.appendChild(item);
                });
            }

            updatePhotoCount();
        }

        // åˆ é™¤ç…§ç‰‡
        async function deletePhoto(index) {
            uploadedPhotos.splice(index, 1);
            await syncPhotosToDB();

            // ä» 3D åœºæ™¯ä¸­ç§»é™¤å¯¹åº”çš„ç…§ç‰‡ meshï¼ˆç´¢å¼•+1æ˜¯å› ä¸ºç¬¬ä¸€ä¸ªæ˜¯é»˜è®¤çš„"åœ£è¯å¿«ä¹"ç…§ç‰‡ï¼‰
            const meshIndex = index + 1;
            if (meshIndex < photoMeshGroup.children.length) {
                const child = photoMeshGroup.children[meshIndex];
                // é‡Šæ”¾ Three.js èµ„æºé˜²æ­¢å†…å­˜æ³„æ¼
                child.traverse((obj) => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (obj.material.map) obj.material.map.dispose();
                        obj.material.dispose();
                    }
                });
                photoMeshGroup.remove(child);
            }

            // ä»ç²’å­ç³»ç»Ÿä¸­ç§»é™¤å¯¹åº”çš„ç…§ç‰‡ç²’å­
            // æ‰¾åˆ°æ‰€æœ‰ PHOTO ç±»å‹çš„ç²’å­ï¼Œç§»é™¤å¯¹åº”ç´¢å¼•çš„é‚£ä¸ªï¼ˆè·³è¿‡ç¬¬ä¸€ä¸ªé»˜è®¤ç…§ç‰‡ï¼‰
            let photoParticleCount = 0;
            for (let i = 0; i < particleSystem.length; i++) {
                if (particleSystem[i].type === 'PHOTO') {
                    if (photoParticleCount === meshIndex) {
                        particleSystem.splice(i, 1);
                        break;
                    }
                    photoParticleCount++;
                }
            }

            renderPhotoGrid();
            showToast(`å·²åˆ é™¤ç…§ç‰‡`);
        }

        // åŒæ­¥ç…§ç‰‡åˆ°æ•°æ®åº“
        async function syncPhotosToDB() {
            if (!db) return;
            const tx = db.transaction([STORE_PHOTOS], 'readwrite');
            const store = tx.objectStore(STORE_PHOTOS);
            store.clear();
            uploadedPhotos.forEach(base64 => store.add(base64));
        }

        // é¢„åŠ è½½æ‰‹åŠ¿æ¨¡å‹ï¼ˆåªåŠ è½½æ¨¡å‹ï¼Œä¸è¯·æ±‚æ‘„åƒå¤´ï¼‰
        let isModelPreloaded = false;
        let hasEnteredPage = false;  // æ ‡è®°æ˜¯å¦å·²è¿›å…¥é¡µé¢
        let gestureCountdownTimer = null;

        function startGestureCountdown() {
            let seconds = 30;
            const countdownEl = document.getElementById('gesture-countdown');
            const tipEl = document.getElementById('gesture-loading-tip');

            if (gestureCountdownTimer) clearInterval(gestureCountdownTimer);
            gestureCountdownTimer = setInterval(() => {
                seconds--;
                if (countdownEl) {
                    if (seconds > 0) {
                        countdownEl.textContent = seconds;
                    } else {
                        if (tipEl) tipEl.innerHTML = 'â›³ åŠ è½½æ‰‹åŠ¿æ“æ§æ¨¡å‹ä¸­...å³å°†å®Œæˆ';
                        clearInterval(gestureCountdownTimer);
                        gestureCountdownTimer = null;
                    }
                }
            }, 1000);
        }

        function stopGestureCountdown() {
            if (gestureCountdownTimer) {
                clearInterval(gestureCountdownTimer);
                gestureCountdownTimer = null;
            }
        }

        async function preloadGestureModel() {
            if (handLandmarker) return;

            const loadingTip = document.getElementById('gesture-loading-tip');
            if (loadingTip && hasEnteredPage) {
                loadingTip.style.display = 'block';
                startGestureCountdown();
            }

            try {
                console.log('[é¢„åŠ è½½] å¼€å§‹åŠ è½½æ‰‹åŠ¿æ¨¡å‹...');
                const vision = await FilesetResolver.forVisionTasks("/js/mediapipe/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "/assets/hand_landmarker.task", delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 2
                });
                isModelPreloaded = true;
                console.log('[é¢„åŠ è½½] æ‰‹åŠ¿æ¨¡å‹åŠ è½½å®Œæˆ');

                if (loadingTip) loadingTip.style.display = 'none';
                stopGestureCountdown();
                const gestureStatus = document.getElementById('gesture-status');
                if (gestureStatus) gestureStatus.innerText = 'æ¨¡å‹å·²åŠ è½½ï¼Œç­‰å¾…å¯åŠ¨...';
            } catch (err) {
                console.error('[é¢„åŠ è½½] æ‰‹åŠ¿æ¨¡å‹åŠ è½½å¤±è´¥:', err);
                if (loadingTip) loadingTip.style.display = 'none';
                stopGestureCountdown();
            }
        }

        // ä½¿ç”¨æ‰‹æœºæ‘„åƒå¤´å¯åŠ¨æ‰‹åŠ¿è¯†åˆ«ï¼ˆPCç«¯ä¸“ç”¨ï¼‰
        async function enableHandTrackingWithPhoneCamera() {
            console.log('[PCç«¯] ä½¿ç”¨æ‰‹æœºæ‘„åƒå¤´å¯åŠ¨æ‰‹åŠ¿è¯†åˆ«...');

            const btn = document.getElementById('camera-btn');
            const loadingTip = document.getElementById('gesture-loading-tip');
            const gestureStatus = document.getElementById('gesture-status');

            try {
                // å¦‚æœæ¨¡å‹è¿˜æ²¡åŠ è½½å®Œæˆï¼Œå…ˆåŠ è½½æ¨¡å‹
                if (!handLandmarker) {
                    console.log('[PCç«¯] æ¨¡å‹æœªåŠ è½½ï¼Œå¼€å§‹åŠ è½½...');
                    if (gestureStatus) gestureStatus.innerText = 'æ­£åœ¨åŠ è½½æ‰‹åŠ¿æ“æ§æ¨¡å‹...';
                    if (loadingTip) {
                        loadingTip.style.display = 'block';
                        startGestureCountdown();
                    }
                    showToast('æ­£åœ¨åŠ è½½AIæ¨¡å‹ï¼Œè¯·ç¨å€™...');

                    const vision = await FilesetResolver.forVisionTasks("/js/mediapipe/wasm");
                    handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: { modelAssetPath: "/assets/hand_landmarker.task", delegate: "GPU" },
                        runningMode: "VIDEO", numHands: 2
                    });

                    console.log('[PCç«¯] æ‰‹åŠ¿æ¨¡å‹åŠ è½½å®Œæˆ');
                    if (loadingTip) loadingTip.style.display = 'none';
                    stopGestureCountdown();
                }

                // åˆå§‹åŒ– webcam canvas å’Œ context
                video = document.getElementById('webcam');
                webcamCanvas = document.getElementById('webcam-preview');
                webcamCtx = webcamCanvas.getContext('2d');
                webcamCanvas.width = 160;
                webcamCanvas.height = 120;

                // æ›´æ–°çŠ¶æ€æç¤º
                if (gestureStatus) gestureStatus.innerText = 'ç­‰å¾…æ‰‹åŠ¿...';

                // å¯åŠ¨æ‰‹åŠ¿æ£€æµ‹å¾ªç¯
                predictWebcam();

                // æ›´æ–°UI
                if (btn) {
                    btn.innerText = "âœ… æ‰‹åŠ¿å·²å¼€å¯";
                    btn.classList.add("active");
                }

                // éšè—è¯·æ±‚æ‘„åƒå¤´æƒé™æŒ‰é’®ï¼ˆä½¿ç”¨æ‰‹æœºæ‘„åƒå¤´æ—¶ä¸éœ€è¦PCæ‘„åƒå¤´æƒé™ï¼‰
                const requestCameraBtnSuccess = document.getElementById('request-camera-btn');
                if (requestCameraBtnSuccess) requestCameraBtnSuccess.style.display = 'none';

                // æ¢å¤çŠ¶æ€æç¤ºé¢œè‰²
                if (gestureStatus) gestureStatus.style.color = '#aaa';

                showToast('æ‰‹æœºæ‘„åƒå¤´å·²å°±ç»ªï¼Œè¯·åœ¨æ‰‹æœºä¸Šåšæ‰‹åŠ¿æ“ä½œ');
                console.log('[PCç«¯] æ‰‹åŠ¿è¯†åˆ«å·²å¯åŠ¨ï¼Œä½¿ç”¨æ‰‹æœºæ‘„åƒå¤´');

            } catch (err) {
                console.error('[PCç«¯] æ‰‹æœºæ‘„åƒå¤´æ‰‹åŠ¿è¯†åˆ«å¯åŠ¨å¤±è´¥:', err);
                if (loadingTip) loadingTip.style.display = 'none';
                stopGestureCountdown();
                if (gestureStatus) {
                    gestureStatus.innerText = 'æ¨¡å‹åŠ è½½å¤±è´¥';
                    gestureStatus.style.color = '#f00';
                }
                showToast('æ‰‹åŠ¿æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•');
            }
        }

        async function enableHandTracking(isAutoStart = false) {
            // é˜²æ­¢é‡å¤åŠ è½½æ‘„åƒå¤´
            if (video && video.srcObject) {
                console.log('[PCç«¯] æ‘„åƒå¤´å·²å¯åŠ¨ï¼Œè·³è¿‡é‡å¤åˆå§‹åŒ–');
                if (!isAutoStart) showToast('æ‰‹åŠ¿è¯†åˆ«å·²åŠ è½½');
                return;
            }

            const btn = document.getElementById('camera-btn');
            const previewToggleBtn = document.getElementById('preview-toggle-btn');
            const loadingTip = document.getElementById('gesture-loading-tip');

            if (!isAutoStart) {
                btn.innerText = "â³ å¯åŠ¨OSSåŠ é€Ÿ...";
                btn.style.opacity = "0.5";
            }

            // æ˜¾ç¤ºåŠ è½½æç¤º
            if (loadingTip) loadingTip.style.display = 'block';

            try {
                if (!isAutoStart) showToast("æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«å¼•æ“...");

                // å¦‚æœæ¨¡å‹è¿˜æ²¡é¢„åŠ è½½å®Œæˆï¼Œå…ˆåŠ è½½æ¨¡å‹
                if (!handLandmarker) {
                    const vision = await FilesetResolver.forVisionTasks("/js/mediapipe/wasm");
                    handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: { modelAssetPath: "/assets/hand_landmarker.task", delegate: "GPU" },
                        runningMode: "VIDEO", numHands: 2
                    });
                }

                video = document.getElementById('webcam');
                webcamCanvas = document.getElementById('webcam-preview');
                webcamCtx = webcamCanvas.getContext('2d');
                webcamCanvas.width = 160; webcamCanvas.height = 120;

                // AIåŠ è½½å®Œæˆï¼Œæ›´æ–°çŠ¶æ€æç¤º
                document.getElementById('gesture-status').innerText = 'ç­‰å¾…æ‰‹åŠ¿...';

                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user", width: { ideal: 320 }, height: { ideal: 240 } } });
                video.srcObject = stream;

                // ç¡®ä¿è§†é¢‘æ’­æ”¾ï¼ˆEdgeæµè§ˆå™¨å…¼å®¹æ€§ï¼‰
                await video.play().catch(e => console.warn('è§†é¢‘è‡ªåŠ¨æ’­æ”¾å¤±è´¥:', e));

                // ç­‰å¾…è§†é¢‘æœ‰è¶³å¤Ÿæ•°æ®åæ‰å¼€å§‹æ£€æµ‹
                await new Promise((resolve) => {
                    if (video.readyState >= video.HAVE_ENOUGH_DATA) {
                        resolve();
                    } else {
                        video.addEventListener('loadeddata', () => resolve(), { once: true });
                    }
                });

                // ç«‹å³ç»˜åˆ¶ä¸€å¸§åˆ°é¢„è§ˆcanvasï¼Œè®©ç”¨æˆ·çœ‹åˆ°æ‘„åƒå¤´ç”»é¢
                if (video.readyState >= video.HAVE_ENOUGH_DATA) {
                    webcamCtx.drawImage(video, 0, 0, 160, 120);
                    console.log('âœ… æ‘„åƒå¤´ç”»é¢å·²æ˜¾ç¤º');
                } else {
                    console.warn('âš ï¸ è§†é¢‘æœªå‡†å¤‡å¥½, readyState:', video.readyState);
                }

                // è¾“å‡ºè§†é¢‘æµä¿¡æ¯åˆ°æ§åˆ¶å°
                console.log('ğŸ“¹ è§†é¢‘æµä¿¡æ¯:', {
                    readyState: video.readyState,
                    videoWidth: video.videoWidth,
                    videoHeight: video.videoHeight,
                    paused: video.paused
                });

                // å¼€å§‹æ‰‹åŠ¿æ£€æµ‹å¾ªç¯
                predictWebcam();

                btn.innerText = "âœ… æ‰‹åŠ¿å·²å¼€å¯";
                btn.classList.add("active");

                if (!isAutoStart) showToast("æ‰‹åŠ¿å·²å¼€å¯");

                // éšè—åŠ è½½æç¤º
                if (loadingTip) loadingTip.style.display = 'none';

                // æˆåŠŸå¯åŠ¨åéšè—è¯·æ±‚æƒé™æŒ‰é’®å¹¶æ¢å¤çŠ¶æ€é¢œè‰²
                const requestCameraBtnSuccess = document.getElementById('request-camera-btn');
                if (requestCameraBtnSuccess) requestCameraBtnSuccess.style.display = 'none';
                document.getElementById('gesture-status').style.color = '#aaa';

            } catch (err) {
                // ç»Ÿä¸€é”™è¯¯å¤„ç†ï¼Œè‡ªåŠ¨å¯åŠ¨å’Œæ‰‹åŠ¨å¯åŠ¨éƒ½æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                console.error('æ‰‹åŠ¿æ£€æµ‹å¯åŠ¨å¤±è´¥:', err);
                console.error('é”™è¯¯è¯¦æƒ…:', {
                    name: err.name,
                    message: err.message,
                    stack: err.stack
                });

                // æ›´è¯¦ç»†çš„é”™è¯¯æç¤º
                let errorMsg = "å¯åŠ¨å¤±è´¥";
                let showRetryBtn = false;  // æ˜¯å¦æ˜¾ç¤ºé‡è¯•æŒ‰é’®

                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    errorMsg = "æ‘„åƒå¤´æƒé™è¢«æ‹’ç»";
                    showRetryBtn = true;
                } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                    errorMsg = "æœªæ‰¾åˆ°æ‘„åƒå¤´";
                    showRetryBtn = true;
                } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                    errorMsg = "æ‘„åƒå¤´è¢«å ç”¨";
                    showRetryBtn = true;
                } else if (err.message && err.message.includes('wasm')) {
                    errorMsg = "æ‰‹åŠ¿æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥";
                }

                if (!isAutoStart) {
                    btn.innerText = "âŒ å¯åŠ¨å¤±è´¥";
                    setTimeout(() => { btn.innerText = "ğŸ–ï¸ å¼€å¯æ‰‹åŠ¿"; btn.style.opacity = "1"; }, 3000);
                    showToast(errorMsg);
                }

                // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                const gestureStatus = document.getElementById('gesture-status');
                gestureStatus.innerText = errorMsg;
                gestureStatus.style.color = '#F00';

                // æ˜¾ç¤ºé‡æ–°è¯·æ±‚æ‘„åƒå¤´æƒé™æŒ‰é’®
                const requestCameraBtn = document.getElementById('request-camera-btn');
                if (requestCameraBtn && showRetryBtn) {
                    requestCameraBtn.style.display = 'block';
                }

                // éšè—åŠ è½½æç¤º
                if (loadingTip) loadingTip.style.display = 'none';
            }
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg; t.style.display = 'block';
            setTimeout(() => { t.style.display = 'none'; }, 3000);
        }

        // --- Confession Logic ---
        let typewriterInterval;
        const DEFAULT_CONFESSION_TEXT = "åœ¨è¿™ä¸ªç‰¹åˆ«çš„åœ£è¯èŠ‚ï¼Œ\næƒ³å¯¹ä½ è¯´ï¼š\n\nMerry Christmas!\næ„¿ä½ çš„ç”Ÿæ´»å……æ»¡é˜³å…‰å’Œæ¸©æš–ã€‚\n\nâ¤ï¸";

        // å‘Šç™½ä¿¡å®šæ—¶å™¨ç®¡ç†
        let confessionTimer1 = null;
        let confessionTimer2 = null;
        let overlayHideTimer = null;

        function showConfession() {
            if (STATE.mode === 'HEART') return;
            
            STATE.mode = 'HEART';
            isSnowing = true;
            if (snowInstancedMesh) snowInstancedMesh.visible = true;
            
            // æ›´æ–°UIå¼€å…³çŠ¶æ€
            const snowToggle = document.getElementById('snow-toggle');
            if (snowToggle) snowToggle.checked = true;

            const overlay = document.getElementById('confession-overlay');
            const envelope = document.getElementById('envelope');
            const textContainer = document.getElementById('confession-text');
            
            if (overlay && textContainer) {
                // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨ï¼Œé˜²æ­¢å†²çª
                if (confessionTimer1) clearTimeout(confessionTimer1);
                if (confessionTimer2) clearTimeout(confessionTimer2);
                if (overlayHideTimer) clearTimeout(overlayHideTimer);

                // ç¡®ä¿æ‰“å­—æœºåœæ­¢
                if (typewriterInterval) clearInterval(typewriterInterval);
                textContainer.textContent = ''; // æ¸…ç©ºå†…å®¹

                overlay.style.display = 'flex';
                // å¼ºåˆ¶é‡ç»˜
                overlay.offsetHeight;
                overlay.classList.add('show');
                
                // é‡ç½®ä¿¡å°çŠ¶æ€
                if (envelope) {
                    // å…ˆç§»é™¤ open ç±»ï¼Œå¹¶å¼ºåˆ¶é‡ç»˜ï¼Œç¡®ä¿ä»å…³é—­çŠ¶æ€å¼€å§‹
                    envelope.classList.remove('open');
                    envelope.offsetHeight; // å¼ºåˆ¶é‡ç»˜
                    
                    // è‡ªåŠ¨æ‰“å¼€åŠ¨ç”»
                    confessionTimer1 = setTimeout(() => {
                        envelope.classList.add('open');
                        
                        // è·å–å‘Šç™½å†…å®¹
                        const savedText = localStorage.getItem('confession_text') || DEFAULT_CONFESSION_TEXT;
                        // å»¶è¿Ÿæ‰“å­—ï¼Œç­‰ä¿¡çº¸å±•å¼€
                        confessionTimer2 = setTimeout(() => {
                            startTypewriter(savedText, textContainer);
                        }, 1000);
                    }, 500);
                }
            }
        }

        function hideConfession() {
            STATE.mode = 'TREE'; // æ¢å¤ä¸ºæ ‘å½¢
            isSnowing = false; // åœæ­¢ä¸‹é›ª
            if (snowInstancedMesh) snowInstancedMesh.visible = false;
             
            // æ›´æ–°UIå¼€å…³çŠ¶æ€
            const snowToggle = document.getElementById('snow-toggle');
            if (snowToggle) snowToggle.checked = false;

            // æ¸…é™¤æ‰€æœ‰å®šæ—¶å™¨
            if (confessionTimer1) clearTimeout(confessionTimer1);
            if (confessionTimer2) clearTimeout(confessionTimer2);
            if (overlayHideTimer) clearTimeout(overlayHideTimer);
            if (typewriterInterval) clearInterval(typewriterInterval);

            const overlay = document.getElementById('confession-overlay');
            const envelope = document.getElementById('envelope');

            if (overlay) {
                overlay.classList.remove('show');
                
                // ç«‹å³å…³é—­ä¿¡å°ï¼Œé¿å…åŠ¨ç”»å¹²æ‰°
                if (envelope) {
                    envelope.classList.remove('open');
                }

                overlayHideTimer = setTimeout(() => {
                    overlay.style.display = 'none';
                }, 500);
            }
        }

        function startTypewriter(text, container) {
            if (typewriterInterval) clearInterval(typewriterInterval);
            container.textContent = '';
            
            let i = 0;
            typewriterInterval = setInterval(() => {
                if (i < text.length) {
                    container.textContent += text.charAt(i);
                    i++;
                    // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
                    container.scrollTop = container.scrollHeight;
                } else {
                    clearInterval(typewriterInterval);
                }
            }, 100); // æ‰“å­—é€Ÿåº¦
        }

        function setupUI() {
            const mainMenuBtn = document.getElementById('main-menu-btn');
            const menuItems = document.getElementById('menu-items');
            const webcamWrapper = document.getElementById('webcam-wrapper');
            const previewToggleBtn = document.getElementById('preview-toggle-btn');
            const toggleUiBtn = document.getElementById('toggle-ui-btn');
            const h1 = document.querySelector('h1');

            // æ‰‹åŠ¿æ“ä½œæç¤ºæ¡†é€»è¾‘
            const instructionBox = document.getElementById('instruction-box');
            const instructionClose = document.getElementById('instruction-close');
            const helpBtn = document.getElementById('help-btn');

            if (instructionClose) {
                instructionClose.addEventListener('click', (e) => {
                    e.stopPropagation();
                    instructionBox.classList.remove('show');
                });
            }

            if (helpBtn) {
                helpBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    togglePanel('instruction-box');
                    // è‡ªåŠ¨å±•å¼€èœå•
                    menuItems.classList.add('show');
                    mainMenuBtn.classList.add('active');
                    mainMenuBtn.innerText = 'âœ–';
                });
            }

            // åˆå§‹æ˜¾ç¤ºæç¤ºæ¡† (å»¶è¿Ÿä¸€ç‚¹ï¼Œä¸”ä»…é¦–æ¬¡è®¿é—®æ˜¾ç¤º)
            setTimeout(() => {
                if (instructionBox) {
                    const INSTRUCTION_SHOWN_KEY = 'xmas_instruction_shown_v1';
                    const hasShown = localStorage.getItem(INSTRUCTION_SHOWN_KEY);
                    
                    if (!hasShown) {
                        togglePanel('instruction-box');
                        localStorage.setItem(INSTRUCTION_SHOWN_KEY, 'true');
                    }
                }
            }, 1500);

            // 1. ä¸»èœå•é€»è¾‘
            mainMenuBtn.addEventListener('click', (e) => {
                e.stopPropagation();

                // å¦‚æœå¤„äºæå°æ¨¡å¼ï¼ˆç•Œé¢éšè—çŠ¶æ€ï¼‰ï¼Œç‚¹å‡»åˆ™æ˜¯å”¤é†’ç•Œé¢
                if (mainMenuBtn.classList.contains('tiny-mode')) {
                    mainMenuBtn.classList.remove('tiny-mode');
                    h1.classList.remove('ui-invisible'); // æ˜¾ç¤ºæ ‡é¢˜
                    // æŒ‰é’®æ¢å¤æ­£å¸¸
                    toggleUiBtn.innerText = "ğŸ‘ï¸ éšè—UIå…ƒç´ (åªæœ‰åœ£è¯æ ‘)";
                    showToast("ç•Œé¢å·²å”¤é†’");
                    return; // å”¤é†’æ—¶åªæ¢å¤æŒ‰é’®ï¼Œä¸è‡ªåŠ¨å±•å¼€èœå•
                }

                // æ­£å¸¸çŠ¶æ€ä¸‹ï¼šåˆ‡æ¢èœå•å±•å¼€
                menuItems.classList.toggle('show');
                mainMenuBtn.classList.toggle('active');
                mainMenuBtn.innerText = menuItems.classList.contains('show') ? 'âœ–' : 'âš™ï¸';
            });

            // 2. éšè—ç•Œé¢é€»è¾‘
            toggleUiBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                // éšè—æ ‡é¢˜
                h1.classList.add('ui-invisible');
                // æ”¶èµ·èœå•
                menuItems.classList.remove('show');
                mainMenuBtn.classList.remove('active');
                mainMenuBtn.innerText = 'âš™ï¸';
                // æŒ‰é’®è¿›å…¥æå°æ¨¡å¼
                mainMenuBtn.classList.add('tiny-mode');

                showToast("ç‚¹å‡»å·¦ä¸‹è§’å…‰ç‚¹å¯å”¤é†’");
            });

            // 3. é¢„è§ˆæ˜¾éš
            previewToggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                isPreviewVisible = !isPreviewVisible;
                webcamWrapper.style.opacity = isPreviewVisible ? 1 : 0;
                previewToggleBtn.innerText = isPreviewVisible ? "ğŸ–¼ï¸ éšè—é¢„è§ˆ" : "ğŸ–¼ï¸ æ˜¾ç¤ºé¢„è§ˆ";
                previewToggleBtn.classList.toggle("active", isPreviewVisible);
            });

            // 4. æ‘„åƒå¤´/æ‰‹åŠ¿æ§åˆ¶æŒ‰é’®
            const cameraBtn = document.getElementById('camera-btn');
            if (cameraBtn) {
                cameraBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // æ£€æŸ¥æ˜¯å¦å·²ç»å¯åŠ¨
                    if (cameraBtn.classList.contains('active')) {
                        showToast("æ‰‹åŠ¿æ§åˆ¶å·²å¼€å¯");
                    } else {
                        // æ‰‹åŠ¨å¯åŠ¨æ‰‹åŠ¿æ£€æµ‹
                        enableHandTracking(false);
                    }
                });
            }

            // 4.5 è¯·æ±‚æ‘„åƒå¤´æƒé™æŒ‰é’®(åœ¨æ‘„åƒå¤´æ¡†å†…)
            const requestCameraBtn = document.getElementById('request-camera-btn');
            if (requestCameraBtn) {
                requestCameraBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    // éšè—æŒ‰é’®å¹¶æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                    requestCameraBtn.style.display = 'none';
                    const gestureStatus = document.getElementById('gesture-status');
                    gestureStatus.innerText = 'æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...';
                    gestureStatus.style.color = '#FFA500';  // æ©™è‰²è¡¨ç¤ºåŠ è½½ä¸­

                    // é‡æ–°å°è¯•å¯åŠ¨æ‰‹åŠ¿æ£€æµ‹
                    await enableHandTracking(false);
                });
            }

            // 6. æ›´å¤šåŠŸèƒ½ä¸‹æ‹‰èœå•
            const moreFunctionsBtn = document.getElementById('more-functions-btn');
            const moreFunctionsMenu = document.getElementById('more-functions-menu');

            if (moreFunctionsBtn && moreFunctionsMenu) {
                moreFunctionsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    moreFunctionsMenu.classList.toggle('show');
                    // æ›´æ–°æŒ‰é’®æ–‡æœ¬
                    if (moreFunctionsMenu.classList.contains('show')) {
                        moreFunctionsBtn.textContent = 'ğŸ”§ æ”¶èµ·åŠŸèƒ½';
                    } else {
                        moreFunctionsBtn.textContent = 'ğŸ”§ æ›´å¤šåŠŸèƒ½';
                    }
                });
            }

            document.getElementById('clear-music-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm("ç¡®å®šè¦æ¢å¤é»˜è®¤éŸ³ä¹å—ï¼Ÿ")) {
                    clearMusicData();
                    // é‡ç½®éŸ³ä¹åç§°æ˜¾ç¤º
                    const currentMusicNameEl = document.getElementById('current-music-name');
                    if (currentMusicNameEl) {
                        currentMusicNameEl.textContent = 'é»˜è®¤éŸ³ä¹';
                    }
                    localStorage.removeItem('customMusicName');
                }
            });

            // ========== é¢æ¿æ‹–åŠ¨å’Œç¼©æ”¾åŠŸèƒ½ ==========
            function initPanelDragAndResize() {
                const panels = document.querySelectorAll('.panel-draggable');

                panels.forEach(panel => {
                    const header = panel.querySelector('.panel-header');
                    const maximizeBtn = panel.querySelector('.panel-maximize-btn');
                    const resizeHandle = panel.querySelector('.panel-resize-handle');

                    let isDragging = false;
                    let isResizing = false;
                    let startX, startY, startLeft, startTop, startWidth, startHeight;

                    // æ‹–åŠ¨åŠŸèƒ½
                    if (header) {
                        header.addEventListener('mousedown', startDrag);
                        header.addEventListener('touchstart', startDrag, { passive: false });
                    }

                    function startDrag(e) {
                        // å¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®ï¼Œä¸å¯åŠ¨æ‹–åŠ¨
                        if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;

                        isDragging = true;
                        panel.classList.add('dragging');

                        const rect = panel.getBoundingClientRect();
                        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                        startX = clientX;
                        startY = clientY;
                        startLeft = rect.left;
                        startTop = rect.top;

                        // ç§»é™¤bottomå®šä½ï¼Œæ”¹ç”¨topå®šä½
                        panel.style.bottom = 'auto';
                        panel.style.left = startLeft + 'px';
                        panel.style.top = startTop + 'px';
                        panel.style.position = 'fixed';

                        document.addEventListener('mousemove', drag);
                        document.addEventListener('mouseup', stopDrag);
                        document.addEventListener('touchmove', drag, { passive: false });
                        document.addEventListener('touchend', stopDrag);

                        e.preventDefault();
                    }

                    function drag(e) {
                        if (!isDragging) return;

                        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                        let newLeft = startLeft + (clientX - startX);
                        let newTop = startTop + (clientY - startY);

                        // è¾¹ç•Œé™åˆ¶
                        newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - panel.offsetWidth));
                        newTop = Math.max(0, Math.min(newTop, window.innerHeight - panel.offsetHeight));

                        panel.style.left = newLeft + 'px';
                        panel.style.top = newTop + 'px';

                        e.preventDefault();
                    }

                    function stopDrag() {
                        isDragging = false;
                        panel.classList.remove('dragging');
                        document.removeEventListener('mousemove', drag);
                        document.removeEventListener('mouseup', stopDrag);
                        document.removeEventListener('touchmove', drag);
                        document.removeEventListener('touchend', stopDrag);
                    }

                    // æ”¾å¤§/ç¼©å°åŠŸèƒ½
                    if (maximizeBtn) {
                        maximizeBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            panel.classList.toggle('panel-maximized');
                            if (panel.classList.contains('panel-maximized')) {
                                maximizeBtn.textContent = 'âœ–';
                                maximizeBtn.title = 'è¿˜åŸ';
                            } else {
                                maximizeBtn.textContent = 'â›¶';
                                maximizeBtn.title = 'æ”¾å¤§';
                                // è¿˜åŸæ—¶é‡ç½®ä½ç½®
                                panel.style.left = '';
                                panel.style.top = '';
                                panel.style.bottom = '';
                                panel.style.width = '';
                                panel.style.height = '';
                                panel.style.position = '';
                            }
                        });
                    }

                    // ç¼©æ”¾åŠŸèƒ½
                    if (resizeHandle) {
                        resizeHandle.addEventListener('mousedown', startResize);
                        resizeHandle.addEventListener('touchstart', startResize, { passive: false });
                    }

                    function startResize(e) {
                        isResizing = true;
                        panel.classList.add('dragging');

                        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                        startX = clientX;
                        startY = clientY;
                        startWidth = panel.offsetWidth;
                        startHeight = panel.offsetHeight;

                        document.addEventListener('mousemove', resize);
                        document.addEventListener('mouseup', stopResize);
                        document.addEventListener('touchmove', resize, { passive: false });
                        document.addEventListener('touchend', stopResize);

                        e.preventDefault();
                        e.stopPropagation();
                    }

                    function resize(e) {
                        if (!isResizing) return;

                        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                        let newWidth = startWidth + (clientX - startX);
                        let newHeight = startHeight + (clientY - startY);

                        // æœ€å°å°ºå¯¸é™åˆ¶
                        newWidth = Math.max(200, newWidth);
                        newHeight = Math.max(150, newHeight);

                        panel.style.width = newWidth + 'px';
                        panel.style.height = newHeight + 'px';
                        panel.style.maxWidth = 'none';
                        panel.style.maxHeight = 'none';

                        e.preventDefault();
                    }

                    function stopResize() {
                        isResizing = false;
                        panel.classList.remove('dragging');
                        document.removeEventListener('mousemove', resize);
                        document.removeEventListener('mouseup', stopResize);
                        document.removeEventListener('touchmove', resize);
                        document.removeEventListener('touchend', stopResize);
                    }
                });
            }

            // åˆå§‹åŒ–é¢æ¿æ‹–åŠ¨å’Œç¼©æ”¾
            initPanelDragAndResize();

            // ========== é¢æ¿ç»Ÿä¸€ç®¡ç† ==========
            const allPanels = {
                'particle-settings': document.getElementById('particle-settings'),
                'title-settings': document.getElementById('title-settings'),
                'music-manager': document.getElementById('music-manager'),
                'photo-manager': document.getElementById('photo-manager'),
                'bg-manager': document.getElementById('bg-manager'),
                'instruction-box': document.getElementById('instruction-box')
            };

            // å…³é—­æ‰€æœ‰é¢æ¿
            function closeAllPanels(exceptId = null) {
                Object.entries(allPanels).forEach(([id, panel]) => {
                    if (id !== exceptId && panel) {
                        panel.classList.remove('show');
                    }
                });
            }

            // åˆ‡æ¢é¢æ¿æ˜¾ç¤ºçŠ¶æ€
            function togglePanel(panelId, callback) {
                const panel = allPanels[panelId];
                if (!panel) return;
                const isOpening = !panel.classList.contains('show');
                if (isOpening) {
                    closeAllPanels(panelId);
                }
                panel.classList.toggle('show');
                if (callback && isOpening) callback();
            }

            // ç»Ÿä¸€çš„ç‚¹å‡»ç©ºç™½å…³é—­é¢æ¿äº‹ä»¶
            document.addEventListener('click', (e) => {
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨é¢æ¿å¤–éƒ¨
                const clickedInsidePanel = Object.values(allPanels).some(panel =>
                    panel && (e.target.closest(`#${panel.id}`) || e.target.closest(`#${panel.id.replace('-manager', '-manage-btn').replace('-settings', '-settings-btn')}`)));
                
                // ç‰¹æ®Šå¤„ç†å¸®åŠ©æŒ‰é’®
                const isHelpBtn = e.target.closest('#help-btn');

                if (!clickedInsidePanel && !isHelpBtn) {
                    // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å¯¹åº”çš„æŒ‰é’®
                    const btnIds = ['particle-settings-btn', 'title-settings-btn', 'music-manage-btn', 'photo-manage-btn', 'bg-manage-btn'];
                    const clickedBtn = btnIds.some(btnId => e.target.closest(`#${btnId}`));
                    if (!clickedBtn) {
                        closeAllPanels();
                    }
                }

                // èœå•å…³é—­é€»è¾‘
                if (!e.target.closest('.menu-container')) {
                    const mainMenuBtn = document.getElementById('main-menu-btn');
                    const menuItems = document.getElementById('menu-items');
                    menuItems.classList.remove('show');
                    if (!mainMenuBtn.classList.contains('tiny-mode')) {
                        mainMenuBtn.classList.remove('active');
                        mainMenuBtn.innerText = 'âš™ï¸';
                    }
                }
            });

            // File inputs
            // ç²’å­è®¾ç½®é¢æ¿é€»è¾‘
            const particleSettingsBtn = document.getElementById('particle-settings-btn');
            const particleSettingsPanel = document.getElementById('particle-settings');
            const particleSettingsClose = document.getElementById('particle-settings-close');
            const particleSlider = document.getElementById('particle-slider');
            const dustSlider = document.getElementById('dust-slider');
            const particleValueSpan = document.getElementById('particle-value');
            const dustValueSpan = document.getElementById('dust-value');
            const applyParticleBtn = document.getElementById('apply-particle-btn');
            const resetParticleBtn = document.getElementById('reset-particle-btn');
            const deviceHint = document.getElementById('device-hint');

            // é»˜è®¤ç²’å­æ•°é‡
            const DEFAULT_PARTICLES = { count: isMobile ? 500 : 1500, dustCount: isMobile ? 600 : 2500 };

            // è®¾ç½®è®¾å¤‡æç¤ºå’Œé»˜è®¤å€¼
            deviceHint.textContent = `å½“å‰è®¾å¤‡: ${isMobile ? 'ğŸ“± ç§»åŠ¨ç«¯' : 'ğŸ’» PCç«¯'}`;

            // è®¾ç½®æ»‘å—èŒƒå›´å’Œå½“å‰å€¼
            if (isMobile) {
                particleSlider.min = 100;
                particleSlider.max = 1000;
                dustSlider.min = 0;
                dustSlider.max = 1500;
            } else {
                particleSlider.min = 300;
                particleSlider.max = 3000;
                dustSlider.min = 0;
                dustSlider.max = 5000;
            }
            particleSlider.value = CONFIG.particles.count;
            dustSlider.value = CONFIG.particles.dustCount;
            particleValueSpan.textContent = CONFIG.particles.count;
            dustValueSpan.textContent = CONFIG.particles.dustCount;

            // æ»‘å—å®æ—¶æ›´æ–°æ˜¾ç¤ºå€¼
            particleSlider.addEventListener('input', () => {
                particleValueSpan.textContent = particleSlider.value;
            });
            dustSlider.addEventListener('input', () => {
                dustValueSpan.textContent = dustSlider.value;
            });

            // æ‰“å¼€ç²’å­è®¾ç½®é¢æ¿
            particleSettingsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                togglePanel('particle-settings');
            });

            // å…³é—­ç²’å­è®¾ç½®é¢æ¿
            particleSettingsClose.addEventListener('click', (e) => {
                e.stopPropagation();
                particleSettingsPanel.classList.remove('show');
            });

            // åº”ç”¨ç²’å­è®¾ç½®
            applyParticleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const newCount = parseInt(particleSlider.value);
                const newDustCount = parseInt(dustSlider.value);

                // ä¿å­˜åˆ° localStorage
                localStorage.setItem(PARTICLE_SETTINGS_KEY, JSON.stringify({
                    count: newCount,
                    dustCount: newDustCount
                }));

                showToast(`âœ¨ ç²’å­è®¾ç½®å·²ä¿å­˜ï¼Œåˆ·æ–°é¡µé¢ç”Ÿæ•ˆ`);
                particleSettingsPanel.classList.remove('show');

                // æç¤ºç”¨æˆ·æ˜¯å¦ç«‹å³åˆ·æ–°
                setTimeout(() => {
                    if (confirm('æ˜¯å¦ç«‹å³åˆ·æ–°é¡µé¢åº”ç”¨æ–°è®¾ç½®ï¼Ÿ')) {
                        location.reload();
                    }
                }, 500);
            });

            // æ¢å¤é»˜è®¤ç²’å­è®¾ç½®
            resetParticleBtn.addEventListener('click', (e) => {
                e.stopPropagation();

                // æ¸…é™¤ localStorage ä¸­çš„è®¾ç½®
                localStorage.removeItem(PARTICLE_SETTINGS_KEY);

                // æ›´æ–°æ»‘å—åˆ°é»˜è®¤å€¼
                particleSlider.value = DEFAULT_PARTICLES.count;
                dustSlider.value = DEFAULT_PARTICLES.dustCount;
                particleValueSpan.textContent = DEFAULT_PARTICLES.count;
                dustValueSpan.textContent = DEFAULT_PARTICLES.dustCount;

                showToast(`ğŸ”„ å·²æ¢å¤é»˜è®¤è®¾ç½®`);

                // å¦‚æœå½“å‰è®¾ç½®ä¸é»˜è®¤ä¸åŒï¼Œæç¤ºåˆ·æ–°
                if (CONFIG.particles.count !== DEFAULT_PARTICLES.count ||
                    CONFIG.particles.dustCount !== DEFAULT_PARTICLES.dustCount) {
                    setTimeout(() => {
                        if (confirm('æ˜¯å¦ç«‹å³åˆ·æ–°é¡µé¢åº”ç”¨é»˜è®¤è®¾ç½®ï¼Ÿ')) {
                            location.reload();
                        }
                    }, 500);
                }
            });

            // æ ‡é¢˜è®¾ç½®é¢æ¿é€»è¾‘
            const titleSettingsBtn = document.getElementById('title-settings-btn');
            const titleSettings = document.getElementById('title-settings');
            const titleSettingsClose = document.getElementById('title-settings-close');
            const mainTitleInput = document.getElementById('main-title-input');
            const enterTitleInput = document.getElementById('enter-title-input');
            const applyTitleBtn = document.getElementById('apply-title-btn');
            const resetTitleBtn = document.getElementById('reset-title-btn');
            const mainTitleEl = document.querySelector('#ui-content h1');
            const enterTitleEl = document.querySelector('.enter-title');
            const DEFAULT_MAIN_TITLE = 'Merry Christmas';
            const DEFAULT_ENTER_TITLE = 'Merry Christmas';

            // åŠ è½½ä¿å­˜çš„æ ‡é¢˜
            function loadSavedTitles() {
                const savedMainTitle = localStorage.getItem('customMainTitle');
                const savedEnterTitle = localStorage.getItem('customEnterTitle');
                if (savedMainTitle) {
                    mainTitleEl.textContent = savedMainTitle;
                    mainTitleInput.value = savedMainTitle;
                }
                if (savedEnterTitle) {
                    enterTitleEl.textContent = savedEnterTitle;
                    enterTitleInput.value = savedEnterTitle;
                }
            }
            loadSavedTitles();

            titleSettingsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                togglePanel('title-settings');
            });

            titleSettingsClose.addEventListener('click', (e) => {
                e.stopPropagation();
                titleSettings.classList.remove('show');
            });

            applyTitleBtn.addEventListener('click', () => {
                const newMainTitle = mainTitleInput.value.trim() || DEFAULT_MAIN_TITLE;
                const newEnterTitle = enterTitleInput.value.trim() || DEFAULT_ENTER_TITLE;
                mainTitleEl.textContent = newMainTitle;
                enterTitleEl.textContent = newEnterTitle;
                localStorage.setItem('customMainTitle', newMainTitle);
                localStorage.setItem('customEnterTitle', newEnterTitle);
                showToast('ğŸ·ï¸ æ ‡é¢˜å·²æ›´æ–°');
                titleSettings.classList.remove('show');
            });

            resetTitleBtn.addEventListener('click', () => {
                mainTitleInput.value = DEFAULT_MAIN_TITLE;
                enterTitleInput.value = DEFAULT_ENTER_TITLE;
                mainTitleEl.textContent = DEFAULT_MAIN_TITLE;
                enterTitleEl.textContent = DEFAULT_ENTER_TITLE;
                localStorage.removeItem('customMainTitle');
                localStorage.removeItem('customEnterTitle');
                showToast('ğŸ”„ æ ‡é¢˜å·²æ¢å¤é»˜è®¤');
            });

            // éŸ³ä¹ç®¡ç†é¢æ¿é€»è¾‘
            const musicManageBtn = document.getElementById('music-manage-btn');
            const musicManager = document.getElementById('music-manager');
            const musicManagerClose = document.getElementById('music-manager-close');
            const currentMusicName = document.getElementById('current-music-name');

            // åŠ è½½ä¿å­˜çš„éŸ³ä¹åç§°
            function loadMusicName() {
                const savedName = localStorage.getItem('customMusicName');
                if (savedName && currentMusicName) {
                    currentMusicName.textContent = savedName;
                }
            }
            loadMusicName();

            musicManageBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                togglePanel('music-manager');
            });

            musicManagerClose.addEventListener('click', (e) => {
                e.stopPropagation();
                musicManager.classList.remove('show');
            });

            // å›¾ç‰‡ç®¡ç†é¢æ¿é€»è¾‘
            const photoManagerBtn = document.getElementById('photo-manage-btn');
            const photoManager = document.getElementById('photo-manager');
            const photoManagerClose = document.getElementById('photo-manager-close');
            const photoGrid = document.getElementById('photo-grid');
            const photoCountSpan = document.getElementById('photo-count');

            // æ‰“å¼€å›¾ç‰‡ç®¡ç†é¢æ¿
            photoManagerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                togglePanel('photo-manager', renderPhotoGrid);
            });

            // å…³é—­å›¾ç‰‡ç®¡ç†é¢æ¿
            photoManagerClose.addEventListener('click', (e) => {
                e.stopPropagation();
                photoManager.classList.remove('show');
            });

            // æ¸…ç©ºç…§ç‰‡æŒ‰é’®
            document.getElementById('clear-photos-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                if (uploadedPhotos.length === 0) {
                    showToast('æš‚æ— ç…§ç‰‡å¯æ¸…ç©º');
                    return;
                }
                if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å·²ä¸Šä¼ çš„ç…§ç‰‡å—ï¼Ÿ')) {
                    // æ¸…ç©ºæ•°æ®åº“
                    clearPhotoData();

                    // æ¸…ç©ºæœ¬åœ°æ•°ç»„
                    uploadedPhotos.length = 0;

                    // æ¸…ç©º 3D åœºæ™¯ä¸­çš„ç…§ç‰‡ï¼ˆä¿ç•™é»˜è®¤çš„åœ£è¯å¿«ä¹ç…§ç‰‡ï¼‰
                    while (photoMeshGroup.children.length > 1) {
                        const child = photoMeshGroup.children[photoMeshGroup.children.length - 1];
                        photoMeshGroup.remove(child);
                    }

                    // ä»ç²’å­ç³»ç»Ÿä¸­ç§»é™¤ç”¨æˆ·ä¸Šä¼ çš„ç…§ç‰‡ç²’å­ï¼ˆä¿ç•™ç¬¬ä¸€ä¸ªé»˜è®¤ç…§ç‰‡ï¼‰
                    const firstPhotoIndex = particleSystem.findIndex(p => p.type === 'PHOTO');
                    for (let i = particleSystem.length - 1; i > firstPhotoIndex; i--) {
                        if (particleSystem[i].type === 'PHOTO') {
                            particleSystem.splice(i, 1);
                        }
                    }

                    // åˆ·æ–°å›¾ç‰‡ç®¡ç†é¢æ¿
                    renderPhotoGrid();

                    showToast('ğŸ—‘ï¸ ç…§ç‰‡å·²æ¸…ç©º');
                }
            });



            // æ–‡ä»¶ä¸Šä¼ å¤„ç†ï¼ˆä¿æŒåŸå›¾ï¼‰
            document.getElementById('file-input').addEventListener('change', (e) => {
                const files = e.target.files; if (!files.length) return;
                const totalFiles = files.length;
                let loadedCount = 0;

                Array.from(files).forEach(f => {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const base64 = ev.target.result;
                        uploadedPhotos.push(base64);
                        savePhotoToDB(base64);
                        new THREE.TextureLoader().load(
                            base64,
                            (t) => { t.colorSpace = THREE.SRGBColorSpace; addPhotoToScene(t); },
                            undefined,
                            (err) => { console.warn('å›¾ç‰‡çº¹ç†åŠ è½½å¤±è´¥:', err); }
                        );
                        loadedCount++;
                        renderPhotoGrid();
                        if (loadedCount === totalFiles) {
                            showToast(`âœ… å·²ä¸Šä¼  ${totalFiles} å¼ ç…§ç‰‡`);
                        }
                    };
                    reader.readAsDataURL(f);
                });
                e.target.value = '';
            });

            document.getElementById('music-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                saveMusicToDB(file);
                localStorage.removeItem(MUSIC_STATE_KEY); // æ›´æ¢éŸ³ä¹æ—¶æ¸…é™¤æš‚åœçŠ¶æ€
                playMusic(file);
                // æ›´æ–°éŸ³ä¹åç§°æ˜¾ç¤º
                const musicName = file.name.replace(/\.[^/.]+$/, "");
                const currentMusicNameEl = document.getElementById('current-music-name');
                if (currentMusicNameEl) {
                    currentMusicNameEl.textContent = musicName;
                }
                localStorage.setItem('customMusicName', musicName);
                showToast("ğŸµ éŸ³ä¹å·²æ›´æ¢");
            });

            // èœå•éŸ³ä¹æ§åˆ¶æŒ‰é’®é€»è¾‘
            const menuMusicToggleBtn = document.getElementById('menu-music-toggle-btn');
            function updateMenuMusicBtn() {
                if (isMusicPlaying) {
                    menuMusicToggleBtn.innerHTML = 'â¸ï¸ æš‚åœéŸ³ä¹';
                    menuMusicToggleBtn.classList.add('active');
                } else {
                    menuMusicToggleBtn.innerHTML = 'â–¶ï¸ æ’­æ”¾éŸ³ä¹';
                    menuMusicToggleBtn.classList.remove('active');
                }
            }
            menuMusicToggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (isMusicPlaying) {
                    bgAudio.pause();
                    updatePlayBtn(false);
                    localStorage.setItem(MUSIC_STATE_KEY, 'paused'); // ç”¨æˆ·æ‰‹åŠ¨æš‚åœ
                } else {
                    bgAudio.play();
                    updatePlayBtn(true);
                    localStorage.setItem(MUSIC_STATE_KEY, 'playing'); // ç”¨æˆ·æ‰‹åŠ¨æ’­æ”¾
                }
                updateMenuMusicBtn();
            });
            // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
            updateMenuMusicBtn();
            // ç›‘å¬éŸ³ä¹çŠ¶æ€å˜åŒ–
            bgAudio.addEventListener('play', () => {
                updatePlayBtn(true);
                updateMenuMusicBtn();
            });
            bgAudio.addEventListener('pause', () => {
                updatePlayBtn(false);
                updateMenuMusicBtn();
            });

            // èƒŒæ™¯è®¾ç½®é¢æ¿é€»è¾‘
            const bgManageBtn = document.getElementById('bg-manage-btn');
            const bgManager = document.getElementById('bg-manager');
            const bgManagerClose = document.getElementById('bg-manager-close');
            const bgInput = document.getElementById('bg-input');
            const resetBgBtn = document.getElementById('reset-bg-btn');

            // æ‰“å¼€èƒŒæ™¯è®¾ç½®é¢æ¿
            bgManageBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                togglePanel('bg-manager');
            });

            // å…³é—­èƒŒæ™¯è®¾ç½®é¢æ¿
            bgManagerClose.addEventListener('click', (e) => {
                e.stopPropagation();
                bgManager.classList.remove('show');
            });

            // ä¸Šä¼ èƒŒæ™¯å›¾ç‰‡
            bgInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const base64 = ev.target.result;
                    saveBackgroundToDB(base64);
                    applyBackgroundImage(base64);
                    updateBgPreview(base64);
                    showToast("ğŸŒŒ èƒŒæ™¯å·²æ›´æ¢");
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            });

            // æ¢å¤é»˜è®¤èƒŒæ™¯
            resetBgBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm('ç¡®å®šè¦æ¢å¤é»˜è®¤èƒŒæ™¯å—ï¼Ÿ')) {
                    clearBackgroundData();
                }
            });

            // å‘Šç™½ä¿¡ç›¸å…³äº‹ä»¶
            const confessionCloseBtn = document.getElementById('confession-close');
            if (confessionCloseBtn) {
                confessionCloseBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    hideConfession();
                });
            }
            
            const snowToggle = document.getElementById('snow-toggle');
            if (snowToggle) {
                snowToggle.addEventListener('change', (e) => {
                    isSnowing = e.target.checked;
                    if (snowInstancedMesh) snowInstancedMesh.visible = isSnowing;
                    if (isSnowing) showToast('â„ï¸ å¼€å§‹ä¸‹é›ª');
                    else showToast('â„ï¸ é›ªåœäº†');
                });
            }

            // å‘Šç™½ä¿¡ç®¡ç†é¢æ¿
            const confessionManageBtn = document.getElementById('confession-manage-btn');
            const confessionManager = document.getElementById('confession-manager');
            const confessionManagerClose = document.getElementById('confession-manager-close');
            const confessionInput = document.getElementById('confession-input');
            const saveConfessionBtn = document.getElementById('save-confession-btn');
            const previewConfessionBtn = document.getElementById('preview-confession-btn');

            if (confessionManageBtn) {
                confessionManageBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // åŠ è½½å·²ä¿å­˜çš„å†…å®¹
                    const savedText = localStorage.getItem('confession_text') || DEFAULT_CONFESSION_TEXT;
                    if (confessionInput) confessionInput.value = savedText;
                    togglePanel('confession-manager');
                });
            }

            if (confessionManagerClose) {
                confessionManagerClose.addEventListener('click', (e) => {
                    e.stopPropagation();
                    confessionManager.classList.remove('show');
                });
            }

            if (saveConfessionBtn) {
                saveConfessionBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const text = confessionInput.value;
                    if (!text.trim()) {
                        showToast('âš ï¸ å†…å®¹ä¸èƒ½ä¸ºç©º');
                        return;
                    }
                    localStorage.setItem('confession_text', text);
                    showToast('âœ… å‘Šç™½ä¿¡å†…å®¹å·²ä¿å­˜');
                    confessionManager.classList.remove('show');
                });
            }

            if (previewConfessionBtn) {
                previewConfessionBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const text = confessionInput.value;
                    if (!text.trim()) {
                        showToast('âš ï¸ å†…å®¹ä¸èƒ½ä¸ºç©º');
                        return;
                    }
                    localStorage.setItem('confession_text', text); // é¢„è§ˆæ—¶è‡ªåŠ¨ä¿å­˜
                    confessionManager.classList.remove('show');
                    showConfession();
                });
            }

            // å°†æ–°é¢æ¿åŠ å…¥ç»Ÿä¸€ç®¡ç†
            allPanels['confession-manager'] = confessionManager;
        }

        // --- Three.js Logic ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.01);
            camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
            adjustCameraPosition();
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping; renderer.toneMappingExposure = 2.2;
            container.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05; controls.enableZoom = true;
            mainGroup = new THREE.Group(); scene.add(mainGroup);
        }

        function adjustCameraPosition() {
            const aspect = window.innerWidth / window.innerHeight;
            if (aspect < 1) camera.position.set(0, 5, CONFIG.camera.z + (1 / aspect) * 15);
            else camera.position.set(0, 2, CONFIG.camera.z);
            camera.lookAt(0, 0, 0);
        }

        function setupEnvironment() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        }

        function setupLights() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambient);
            const innerLight = new THREE.PointLight(0xffaa00, 2, 20); innerLight.position.set(0, 5, 0); mainGroup.add(innerLight);
            const spotGold = new THREE.SpotLight(0xffcc66, 1200); spotGold.position.set(30, 40, 40); scene.add(spotGold);
            const spotBlue = new THREE.SpotLight(0x6688ff, 600); spotBlue.position.set(-30, 20, -30); scene.add(spotBlue);
            const fill = new THREE.DirectionalLight(0xffeebb, 0.8); fill.position.set(0, 0, 50); scene.add(fill);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            const bloomRadius = isMobile ? 0.2 : 0.4;
            const pixelRatio = Math.min(window.devicePixelRatio, 2);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth * pixelRatio, window.innerHeight * pixelRatio),
                1.5,
                bloomRadius,
                0.85
            );
            bloomPass.threshold = 0.7; bloomPass.strength = 0.45; bloomPass.radius = bloomRadius;
            composer = new EffectComposer(renderer);
            composer.setPixelRatio(pixelRatio);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        function createTextures() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = '#880000'; ctx.beginPath();
            for (let i = -128; i < 256; i += 32) { ctx.moveTo(i, 0); ctx.lineTo(i + 32, 128); ctx.lineTo(i + 16, 128); ctx.lineTo(i - 16, 0); }
            ctx.fill();
            caneTexture = new THREE.CanvasTexture(canvas); caneTexture.wrapS = THREE.RepeatWrapping; caneTexture.wrapT = THREE.RepeatWrapping; caneTexture.repeat.set(3, 3);
        }

        // ç…§ç‰‡ç²’å­ç±»ï¼ˆä¿æŒ Mesh æ–¹å¼ï¼Œå› ä¸ºæ¯ä¸ªçº¹ç†ä¸åŒï¼‰
        class PhotoParticle {
            constructor(mesh) {
                this.mesh = mesh;
                this.type = 'PHOTO';
                this.posTree = new THREE.Vector3();
                this.posScatter = new THREE.Vector3();
                this.baseScale = mesh.scale.x;
                this.spinSpeed = new THREE.Vector3((Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3);
                this.calculatePositions();
            }
            calculatePositions() {
                const h = CONFIG.particles.treeHeight;
                let t = Math.random(); t = Math.pow(t, 0.8);
                const y = (t * h) - (h / 2);
                let rMax = CONFIG.particles.treeRadius * (1.0 - t); if (rMax < 0.5) rMax = 0.5;
                const angle = t * 50 * Math.PI + Math.random() * Math.PI;
                const r = rMax * (0.8 + Math.random() * 0.4);
                this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
                const rScatter = 8 + Math.random() * 12;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(rScatter * Math.sin(phi) * Math.cos(theta), rScatter * Math.sin(phi) * Math.sin(theta), rScatter * Math.cos(phi));
            }
            update(dt, mode, focusTargetMesh) {
                let target = this.posTree;
                if (mode === 'SCATTER') target = this.posScatter;
                else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) {
                        const zOffset = isMobile ? 45 : 35;
                        const desiredWorldPos = new THREE.Vector3(0, 2, zOffset);
                        const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
                        target = desiredWorldPos.applyMatrix4(invMatrix);
                    } else { target = this.posScatter; }
                }
                const lerpSpeed = (mode === 'FOCUS' && this.mesh === focusTargetMesh) ? 5.0 : 2.0;
                this.mesh.position.lerp(target, lerpSpeed * dt);
                if (mode === 'SCATTER') {
                    this.mesh.rotation.x += this.spinSpeed.x * dt;
                    this.mesh.rotation.y += this.spinSpeed.y * dt;
                    this.mesh.rotation.z += this.spinSpeed.z * dt;
                } else if (mode === 'TREE') {
                    this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt);
                    this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt);
                    this.mesh.rotation.y += 0.5 * dt;
                }
                if (mode === 'FOCUS' && this.mesh === focusTargetMesh) this.mesh.lookAt(camera.position);
                let s = this.baseScale;
                if (mode === 'SCATTER') s = this.baseScale * 2.5;
                else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) s = isMobile ? 3.5 : 4.5;
                    else s = this.baseScale * 0.8;
                }
                this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 4 * dt);
            }
        }

        // è®¡ç®—ç²’å­åœ¨æ ‘å½¢å’Œæ•£å¼€æ¨¡å¼ä¸‹çš„ä½ç½®
        function calculateParticlePositions(isDust = false) {
            const h = CONFIG.particles.treeHeight;
            let t = Math.random(); t = Math.pow(t, 0.8);
            const y = (t * h) - (h / 2);
            let rMax = CONFIG.particles.treeRadius * (1.0 - t); if (rMax < 0.5) rMax = 0.5;
            const angle = t * 50 * Math.PI + Math.random() * Math.PI;
            const r = rMax * (0.8 + Math.random() * 0.4);
            const posTree = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);

            const rScatter = isDust ? (12 + Math.random() * 20) : (8 + Math.random() * 12);
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const posScatter = new THREE.Vector3(
                rScatter * Math.sin(phi) * Math.cos(theta),
                rScatter * Math.sin(phi) * Math.sin(theta),
                rScatter * Math.cos(phi)
            );

            return { posTree, posScatter };
        }

        function createParticles() {
            const sphereGeo = new THREE.SphereGeometry(0.5, 12, 12);
            const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55);
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, -0.5, 0),
                new THREE.Vector3(0, 0.3, 0),
                new THREE.Vector3(0.1, 0.5, 0),
                new THREE.Vector3(0.3, 0.4, 0)
            ]);
            const candyGeo = new THREE.TubeGeometry(curve, 8, 0.08, 5, false);

            const goldMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.champagneGold, metalness: 1.0, roughness: 0.1, envMapIntensity: 2.0, emissive: 0x443300, emissiveIntensity: 0.3 });
            const greenMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.deepGreen, metalness: 0.2, roughness: 0.8, emissive: 0x002200, emissiveIntensity: 0.2 });
            const redMat = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.accentRed, metalness: 0.3, roughness: 0.2, clearcoat: 1.0, emissive: 0x330000 });
            const candyMat = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.4 });

            // å…ˆç»Ÿè®¡å„ç±»å‹ç²’å­æ•°é‡
            const counts = { BOX: 0, GOLD_BOX: 0, GOLD_SPHERE: 0, RED: 0, CANE: 0 };
            const typeAssignments = [];

            for (let i = 0; i < CONFIG.particles.count; i++) {
                const rand = Math.random();
                let type;
                if (rand < 0.40) type = 'BOX';
                else if (rand < 0.70) type = 'GOLD_BOX';
                else if (rand < 0.92) type = 'GOLD_SPHERE';
                else if (rand < 0.97) type = 'RED';
                else type = 'CANE';
                counts[type]++;
                typeAssignments.push(type);
            }

            // åˆ›å»º InstancedMesh
            instancedMeshes = {
                BOX: new THREE.InstancedMesh(boxGeo, greenMat, counts.BOX),
                GOLD_BOX: new THREE.InstancedMesh(boxGeo, goldMat, counts.GOLD_BOX),
                GOLD_SPHERE: new THREE.InstancedMesh(sphereGeo, goldMat, counts.GOLD_SPHERE),
                RED: new THREE.InstancedMesh(sphereGeo, redMat, counts.RED),
                CANE: new THREE.InstancedMesh(candyGeo, candyMat, counts.CANE)
            };

            // æ·»åŠ åˆ°åœºæ™¯
            Object.values(instancedMeshes).forEach(mesh => {
                mesh.frustumCulled = false;  // ç¦ç”¨è§†é”¥å‰”é™¤ï¼Œé¿å…ç²’å­æ¶ˆå¤±
                mainGroup.add(mesh);
            });

            // ä¸ºæ¯ä¸ªç±»å‹ç»´æŠ¤ç´¢å¼•è®¡æ•°å™¨
            const indices = { BOX: 0, GOLD_BOX: 0, GOLD_SPHERE: 0, RED: 0, CANE: 0 };

            // åˆå§‹åŒ–ç²’å­æ•°æ®
            for (let i = 0; i < CONFIG.particles.count; i++) {
                const type = typeAssignments[i];
                const { posTree, posScatter } = calculateParticlePositions(false);
                const baseScale = 0.4 + Math.random() * 0.5;
                const rotation = new THREE.Euler(Math.random() * 6, Math.random() * 6, Math.random() * 6);
                const spinSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * 2.0,
                    (Math.random() - 0.5) * 2.0,
                    (Math.random() - 0.5) * 2.0
                );

                const pData = {
                    type,
                    instanceIndex: indices[type],
                    position: posTree.clone(),
                    rotation: rotation.clone(),
                    scale: baseScale,
                    baseScale,
                    posTree,
                    posScatter,
                    spinSpeed
                };

                particleData.push(pData);
                indices[type]++;

                // è®¾ç½®åˆå§‹çŸ©é˜µ
                dummy.position.copy(posTree);
                dummy.rotation.copy(rotation);
                dummy.scale.setScalar(baseScale);
                dummy.updateMatrix();
                instancedMeshes[type].setMatrixAt(pData.instanceIndex, dummy.matrix);
            }

            // æ ‡è®°çŸ©é˜µéœ€è¦æ›´æ–°
            Object.values(instancedMeshes).forEach(mesh => {
                mesh.instanceMatrix.needsUpdate = true;
            });

            // æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(1.2, 0);
            const starMat = new THREE.MeshStandardMaterial({ color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 1.0, metalness: 1.0, roughness: 0 });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0);
            mainGroup.add(star);
            mainGroup.add(photoMeshGroup);
        }

        function createDust() {
            const dustCount = CONFIG.particles.dustCount;
            if (dustCount === 0) return;

            // ä½¿ç”¨å››é¢ä½“å‡ ä½•ä½“ï¼ˆä¿æŒåŸæœ‰çš„ 3D æ•ˆæœï¼‰
            const dustGeo = new THREE.TetrahedronGeometry(0.08, 0);
            const dustMat = new THREE.MeshBasicMaterial({
                color: 0xffeebb,
                transparent: true,
                opacity: 0.8
            });

            // åˆ›å»º InstancedMesh
            dustInstancedMesh = new THREE.InstancedMesh(dustGeo, dustMat, dustCount);
            dustInstancedMesh.frustumCulled = false;

            // åˆå§‹åŒ–ç°å°˜ç²’å­æ•°æ®
            for (let i = 0; i < dustCount; i++) {
                const { posTree, posScatter } = calculateParticlePositions(true);
                const baseScale = 0.5 + Math.random();
                const rotation = new THREE.Euler(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
                const spinSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 3
                );

                dustData.push({
                    position: posTree.clone(),
                    rotation: rotation.clone(),
                    posTree,
                    posScatter,
                    baseScale,
                    scale: 0,  // æ ‘å½¢æ¨¡å¼ä¸‹åˆå§‹ä¸º0
                    spinSpeed,
                    id: i
                });

                // è®¾ç½®åˆå§‹çŸ©é˜µï¼ˆç¼©æ”¾ä¸º0ï¼Œä¸å¯è§ï¼‰
                dummy.position.copy(posTree);
                dummy.rotation.copy(rotation);
                dummy.scale.setScalar(0);
                dummy.updateMatrix();
                dustInstancedMesh.setMatrixAt(i, dummy.matrix);
            }

            dustInstancedMesh.instanceMatrix.needsUpdate = true;
            mainGroup.add(dustInstancedMesh);
        }

        function createSnow() {
            const snowCount = 1000; // é›ªèŠ±æ•°é‡
            const snowGeo = new THREE.TetrahedronGeometry(0.1, 0); // ä½¿ç”¨å››é¢ä½“æ¨¡æ‹Ÿé›ªèŠ±
            const snowMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });

            snowInstancedMesh = new THREE.InstancedMesh(snowGeo, snowMat, snowCount);
            snowInstancedMesh.frustumCulled = false;

            for (let i = 0; i < snowCount; i++) {
                const x = (Math.random() - 0.5) * 60;
                const y = (Math.random() - 0.5) * 60;
                const z = (Math.random() - 0.5) * 60;
                const position = new THREE.Vector3(x, y, z);
                
                const rotation = new THREE.Euler(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );

                const scale = 0.5 + Math.random() * 0.5;

                snowData.push({
                    position: position,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1, // Xè½´è½»å¾®é£˜åŠ¨
                        -0.05 - Math.random() * 0.1, // Yè½´ä¸‹è½
                        (Math.random() - 0.5) * 0.1  // Zè½´è½»å¾®é£˜åŠ¨
                    ),
                    rotation: rotation,
                    rotSpeed: new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2
                    ),
                    scale: scale
                });

                dummy.position.copy(position);
                dummy.rotation.copy(rotation);
                dummy.scale.setScalar(scale);
                dummy.updateMatrix();
                snowInstancedMesh.setMatrixAt(i, dummy.matrix);
            }

            snowInstancedMesh.instanceMatrix.needsUpdate = true;
            snowInstancedMesh.visible = isSnowing;
            mainGroup.add(snowInstancedMesh);
        }

        function createDefaultPhotos() {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512; const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, 512, 512); ctx.strokeStyle = '#eebb66'; ctx.lineWidth = 15; ctx.strokeRect(20, 20, 472, 472);
            ctx.font = '600 80px "Microsoft YaHei", "SimHei", serif'; ctx.fillStyle = '#eebb66'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText("åœ£è¯", 256, 200); ctx.fillText("å¿«ä¹", 256, 320);
            const tex = new THREE.CanvasTexture(canvas); tex.colorSpace = THREE.SRGBColorSpace; addPhotoToScene(tex);
        }

        function addPhotoToScene(texture) {
            // æ ¹æ®å›¾ç‰‡å®é™…æ¯”ä¾‹è®¡ç®—å°ºå¯¸
            const maxSize = 1.2;  // æœ€å¤§è¾¹é•¿
            const borderWidth = 0.1;  // ç›¸æ¡†è¾¹æ¡†å®½åº¦
            let photoWidth = maxSize;
            let photoHeight = maxSize;

            // ä¼˜åŒ–çº¹ç†è´¨é‡ï¼šè®¾ç½®é«˜è´¨é‡è¿‡æ»¤
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();  // æœ€å¤§å„å‘å¼‚æ€§è¿‡æ»¤ï¼Œæå‡æ¸…æ™°åº¦
            texture.generateMipmaps = true;
            texture.needsUpdate = true;

            // è·å–çº¹ç†çš„åŸå§‹å›¾ç‰‡å°ºå¯¸
            if (texture.image) {
                const imgWidth = texture.image.width || texture.image.videoWidth || 1;
                const imgHeight = texture.image.height || texture.image.videoHeight || 1;
                const aspectRatio = imgWidth / imgHeight;

                if (aspectRatio > 1) {
                    // æ¨ªå‘å›¾ç‰‡ï¼šå®½åº¦ä¸ºæœ€å¤§ï¼Œé«˜åº¦æŒ‰æ¯”ä¾‹ç¼©å°
                    photoWidth = maxSize;
                    photoHeight = maxSize / aspectRatio;
                } else if (aspectRatio < 1) {
                    // çºµå‘å›¾ç‰‡ï¼šé«˜åº¦ä¸ºæœ€å¤§ï¼Œå®½åº¦æŒ‰æ¯”ä¾‹ç¼©å°
                    photoHeight = maxSize;
                    photoWidth = maxSize * aspectRatio;
                }
            }

            // ç›¸æ¡†å°ºå¯¸ = ç…§ç‰‡å°ºå¯¸ + è¾¹æ¡†
            const frameWidth = photoWidth + borderWidth * 2;
            const frameHeight = photoHeight + borderWidth * 2;

            const frameGeo = new THREE.BoxGeometry(frameWidth, frameHeight, 0.05);
            const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.champagneGold, metalness: 1.0, roughness: 0.1, envMapIntensity: 2.0, emissive: 0x886622, emissiveIntensity: 0.5 });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            const photoGeo = new THREE.PlaneGeometry(photoWidth, photoHeight);
            // é™ä½å›¾ç‰‡äº®åº¦ï¼šcolor ä¸çº¹ç†ç›¸ä¹˜ï¼Œ0xaaaaaa çº¦ä¸º 67% äº®åº¦
            const photoMat = new THREE.MeshBasicMaterial({
                map: texture,
                toneMapped: false,
                color: 0xdedede,  // è°ƒæ•´äº®åº¦ï¼ˆ87%ï¼‰
                transparent: true,
                side: THREE.DoubleSide
            });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.04;
            const group = new THREE.Group();
            group.add(frame);
            group.add(photo);
            const s = 0.8;
            group.scale.set(s, s, s);
            photoMeshGroup.add(group);
            particleSystem.push(new PhotoParticle(group));
        }

        // æ›´æ–° InstancedMesh ç²’å­ï¼ˆåˆ†å¸§æ›´æ–°ï¼‰
        function updateInstancedParticles(dt) {
            const mode = STATE.mode;
            const needsUpdate = {};
            const len = particleData.length;

            // æ¯å¸§åªæ›´æ–°ä¸€éƒ¨åˆ†ç²’å­
            const endIndex = Math.min(particleUpdateIndex + PARTICLES_PER_FRAME, len);

            for (let i = particleUpdateIndex; i < endIndex; i++) {
                const p = particleData[i];
                let target;
                
                if (mode === 'SCATTER' || mode === 'FOCUS') {
                    target = p.posScatter;
                } else if (mode === 'HEART') {
                    // åˆæ‹¢æ•ˆæœï¼šå‘ä¸­å¿ƒèšé›†
                    target = new THREE.Vector3(0, 0, 0);
                } else {
                    target = p.posTree;
                }

                // ä½ç½®æ’å€¼
                p.position.lerp(target, (mode === 'HEART' ? 1.0 : 2.0) * dt);

                // æ—‹è½¬æ›´æ–°
                if (mode === 'SCATTER') {
                    p.rotation.x += p.spinSpeed.x * dt;
                    p.rotation.y += p.spinSpeed.y * dt;
                    p.rotation.z += p.spinSpeed.z * dt;
                } else if (mode === 'TREE') {
                    p.rotation.x *= 0.99;
                    p.rotation.z *= 0.99;
                    p.rotation.y += 0.5 * dt;
                } else if (mode === 'HEART') {
                     p.rotation.x += p.spinSpeed.x * dt * 0.5;
                     p.rotation.y += p.spinSpeed.y * dt * 0.5;
                     p.rotation.z += p.spinSpeed.z * dt * 0.5;
                }

                // ç¼©æ”¾
                let targetScale = p.baseScale;
                if (mode === 'FOCUS') targetScale = p.baseScale * 0.8;
                else if (mode === 'HEART') targetScale = p.baseScale * 0.5; // å˜å°
                
                p.scale += (targetScale - p.scale) * 4 * dt;

                // æ›´æ–°çŸ©é˜µ
                dummy.position.copy(p.position);
                dummy.rotation.set(p.rotation.x, p.rotation.y, p.rotation.z);
                dummy.scale.setScalar(p.scale);
                dummy.updateMatrix();
                instancedMeshes[p.type].setMatrixAt(p.instanceIndex, dummy.matrix);
                needsUpdate[p.type] = true;
            }

            // æ›´æ–°ç´¢å¼•ï¼Œå¾ªç¯
            particleUpdateIndex = endIndex >= len ? 0 : endIndex;

            // æ ‡è®°éœ€è¦æ›´æ–°çš„ InstancedMesh
            for (const type in needsUpdate) {
                instancedMeshes[type].instanceMatrix.needsUpdate = true;
            }
        }

        // æ›´æ–°ç°å°˜ç²’å­ï¼ˆä½¿ç”¨ InstancedMeshï¼‰
        function updateDustParticles(dt) {
            if (!dustInstancedMesh || dustData.length === 0) return;

            const mode = STATE.mode;
            const elapsed = clock.elapsedTime;
            const len = dustData.length;
            const isVisible = mode !== 'TREE';

            // æ¯å¸§æ›´æ–°æ‰€æœ‰ç°å°˜
            const endIndex = Math.min(dustUpdateIndex + DUST_PER_FRAME, len);

            for (let i = dustUpdateIndex; i < endIndex; i++) {
                const d = dustData[i];
                const target = isVisible ? d.posScatter : d.posTree;

                // ä½ç½®æ’å€¼
                d.position.lerp(target, 2.0 * dt);

                // æ—‹è½¬æ›´æ–°ï¼ˆæ•£å¼€æ—¶æ—‹è½¬ï¼‰
                if (isVisible) {
                    d.rotation.x += d.spinSpeed.x * dt;
                    d.rotation.y += d.spinSpeed.y * dt;
                    d.rotation.z += d.spinSpeed.z * dt;
                }

                // å‘¼å¸æ•ˆæœçš„ç¼©æ”¾
                const targetScale = isVisible ? d.baseScale * (0.8 + 0.4 * Math.sin(elapsed * 4 + d.id)) : 0;
                d.scale += (targetScale - d.scale) * 4 * dt;

                // æ›´æ–°çŸ©é˜µ
                dummy.position.copy(d.position);
                dummy.rotation.set(d.rotation.x, d.rotation.y, d.rotation.z);
                dummy.scale.setScalar(d.scale);
                dummy.updateMatrix();
                dustInstancedMesh.setMatrixAt(i, dummy.matrix);
            }

            // æ›´æ–°ç´¢å¼•ï¼Œå¾ªç¯
            dustUpdateIndex = endIndex >= len ? 0 : endIndex;

            dustInstancedMesh.instanceMatrix.needsUpdate = true;
        }

        function updateSnowParticles(dt) {
            if (!snowInstancedMesh || !isSnowing) return;

            const len = snowData.length;
            for (let i = 0; i < len; i++) {
                const s = snowData[i];
                
                // æ›´æ–°ä½ç½®
                s.position.add(s.velocity);
                
                // è¾¹ç•Œæ£€æŸ¥ï¼šå¦‚æœè¶…å‡ºèŒƒå›´ï¼Œé‡ç½®åˆ°é¡¶éƒ¨
                if (s.position.y < -30) {
                    s.position.y = 30;
                    s.position.x = (Math.random() - 0.5) * 60;
                    s.position.z = (Math.random() - 0.5) * 60;
                }

                // æ—‹è½¬
                s.rotation.x += s.rotSpeed.x * dt;
                s.rotation.y += s.rotSpeed.y * dt;
                s.rotation.z += s.rotSpeed.z * dt;

                // æ›´æ–°çŸ©é˜µ
                dummy.position.copy(s.position);
                dummy.rotation.set(s.rotation.x, s.rotation.y, s.rotation.z);
                dummy.scale.setScalar(s.scale);
                dummy.updateMatrix();
                snowInstancedMesh.setMatrixAt(i, dummy.matrix);
            }
            snowInstancedMesh.instanceMatrix.needsUpdate = true;
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); adjustCameraPosition();
                const pixelRatio = Math.min(window.devicePixelRatio, 2);
                renderer.setPixelRatio(pixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setPixelRatio(pixelRatio);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        let lastVideoTime = -1;
        let lastDetectionTime = 0;
        let noHandFrameCount = 0;  // è¿ç»­æœªæ£€æµ‹åˆ°æ‰‹çš„å¸§æ•°
        const DETECTION_INTERVAL = 50;  // æ£€æµ‹é—´éš”(ms)ï¼Œé˜²æ­¢è¿‡äºé¢‘ç¹
        const MAX_NO_HAND_FRAMES = 60;  // æœ€å¤§è¿ç»­æ— æ‰‹å¸§æ•°ï¼Œè¶…è¿‡åé‡ç½®çŠ¶æ€

        async function predictWebcam() {
            const now = performance.now();

            // èŠ‚æµï¼šæ§åˆ¶æ£€æµ‹é¢‘ç‡ï¼Œé˜²æ­¢è¿‡äºé¢‘ç¹å¯¼è‡´å¡ä½
            if (now - lastDetectionTime < DETECTION_INTERVAL) {
                requestAnimationFrame(predictWebcam);
                return;
            }

            // æ£€æŸ¥è§†é¢‘æ˜¯å¦æœ‰æ–°å¸§æˆ–è€…éœ€è¦å¼ºåˆ¶æ£€æµ‹
            // å³ä½¿ currentTime ç›¸åŒï¼Œä¹Ÿå‘¨æœŸæ€§è¿›è¡Œæ£€æµ‹é˜²æ­¢å¡ä½
            const videoTimeChanged = video.currentTime !== lastVideoTime;
            const forceDetection = (now - lastDetectionTime) > 200;  // è¶…è¿‡200mså¼ºåˆ¶æ£€æµ‹

            if ((videoTimeChanged || forceDetection) && video.readyState >= video.HAVE_CURRENT_DATA) {
                lastVideoTime = video.currentTime;
                lastDetectionTime = now;

                if (handLandmarker) {
                    try {
                        const result = handLandmarker.detectForVideo(video, now);
                        processGestures(result);

                        // è·Ÿè¸ªè¿ç»­æœªæ£€æµ‹åˆ°æ‰‹çš„å¸§æ•°
                        if (!result.landmarks || result.landmarks.length === 0) {
                            noHandFrameCount++;
                            // å¦‚æœè¿ç»­å¤ªå¤šå¸§æ²¡æ£€æµ‹åˆ°æ‰‹ï¼Œé‡ç½®æ£€æµ‹çŠ¶æ€
                            if (noHandFrameCount > MAX_NO_HAND_FRAMES) {
                                noHandFrameCount = 0;
                                lastVideoTime = -1;  // é‡ç½®ä»¥ç¡®ä¿ä¸‹æ¬¡èƒ½æ£€æµ‹
                            }
                        } else {
                            noHandFrameCount = 0;  // æ£€æµ‹åˆ°æ‰‹ï¼Œé‡ç½®è®¡æ•°
                        }
                    } catch (e) {
                        // æ•è·æ£€æµ‹é”™è¯¯ï¼Œé˜²æ­¢æ•´ä¸ªå¾ªç¯å´©æºƒ
                        console.warn('æ‰‹åŠ¿æ£€æµ‹å‡ºé”™:', e);
                        noHandFrameCount++;
                    }
                }
            }

            requestAnimationFrame(predictWebcam);
        }

        function processGestures(result) {
            if (video && video.readyState >= video.HAVE_ENOUGH_DATA && webcamCtx) {
                try {
                    webcamCtx.drawImage(video, 0, 0, 160, 120);
                } catch (e) {
                    console.warn('ç»˜åˆ¶è§†é¢‘å¸§å¤±è´¥:', e);
                }
            }

            // å¦‚æœå¤„äºå‘Šç™½æ¨¡å¼ï¼ˆHEARTï¼‰ï¼Œæš‚åœæ‰‹åŠ¿æ§åˆ¶
            if (STATE.mode === 'HEART') {
                updateGestureStatus("â¤ï¸ æ­£åœ¨å‘Šç™½...", "#ff4081");
                return;
            }

            if (result.landmarks && result.landmarks.length > 0) {
                STATE.hand.detected = true;
                
                // ç»˜åˆ¶å…³é”®ç‚¹
                if (webcamCtx) {
                    webcamCtx.fillStyle = "#0f0";
                    for (const landmarks of result.landmarks) {
                        for (let p of landmarks) {
                            webcamCtx.beginPath();
                            webcamCtx.arc(p.x * 160, p.y * 120, 2, 0, 2 * Math.PI);
                            webcamCtx.fill();
                        }
                    }
                }

                // æ£€æµ‹çˆ±å¿ƒæ‰‹åŠ¿ (éœ€è¦ä¸¤åªæ‰‹)
                if (result.landmarks.length === 2) {
                    const hand1 = result.landmarks[0];
                    const hand2 = result.landmarks[1];

                    // è·å–æ‹‡æŒ‡æŒ‡å°–(4)å’Œé£ŸæŒ‡æŒ‡å°–(8)
                    const h1_4 = hand1[4];
                    const h1_8 = hand1[8];
                    const h2_4 = hand2[4];
                    const h2_8 = hand2[8];

                    // è®¡ç®—ä¸¤æ‰‹æ‹‡æŒ‡æŒ‡å°–è·ç¦»å’Œé£ŸæŒ‡æŒ‡å°–è·ç¦»
                    const thumbDist = Math.hypot(h1_4.x - h2_4.x, h1_4.y - h2_4.y);
                    const indexDist = Math.hypot(h1_8.x - h2_8.x, h1_8.y - h2_8.y);

                    // é˜ˆå€¼åˆ¤æ–­ (æ ¹æ®å®é™…æµ‹è¯•è°ƒæ•´)
                    if (thumbDist < 0.2 && indexDist < 0.2) {
                        // è§¦å‘å‘Šç™½æ¨¡å¼
                        showConfession();
                        return;
                    }
                }

                // å•æ‰‹æ‰‹åŠ¿é€»è¾‘ (å–ç¬¬ä¸€åªæ‰‹)
                const lm = result.landmarks[0];
                const handX = (lm[9].x - 0.5) * -2;
                const handY = (lm[9].y - 0.5) * 2;

                STATE.hand.x = handX;
                STATE.hand.y = handY;

                const thumbTip = lm[4];
                const indexTip = lm[8];
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

                let detectedMode = STATE.mode;

                if (pinchDist < 0.05) {
                    detectedMode = 'FOCUS';
                    if (STATE.mode !== 'FOCUS') {
                        STATE.mode = 'FOCUS';
                        const photos = particleSystem.filter(p => p.type === 'PHOTO');
                        if (photos.length) STATE.focusTarget = photos[Math.floor(Math.random() * photos.length)].mesh;
                    }
                    updateGestureStatus("çŠ¶æ€: é€‰ä¸­ (æåˆ)", "#FFD700");
                    return;
                }

                const wrist = lm[0];
                let extendedFingers = 0;
                const fingerIndices = [8, 12, 16, 20];
                const pipIndices = [6, 10, 14, 18];

                for (let i = 0; i < 4; i++) {
                    const tip = lm[fingerIndices[i]];
                    const pip = lm[pipIndices[i]];
                    const distTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                    const distPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
                    if (distTip > distPip * 1.1) extendedFingers++;
                }

                if (extendedFingers >= 4) {
                    detectedMode = 'SCATTER';
                    STATE.mode = 'SCATTER';
                    STATE.focusTarget = null;
                    updateGestureStatus("çŠ¶æ€: æ—‹è½¬ (å¼ æ‰‹)", "#00FF00");
                } else if (extendedFingers <= 1) {
                    detectedMode = 'TREE';
                    STATE.mode = 'TREE';
                    STATE.focusTarget = null;
                    updateGestureStatus("çŠ¶æ€: è¿˜åŸ (æ‹³å¤´)", "#00FFFF");
                } else {
                    updateGestureStatus("çŠ¶æ€: ä¿æŒ...", "#fff");
                }

            } else {
                STATE.hand.detected = false;
                updateGestureStatus("æœªæ£€æµ‹åˆ°æ‰‹", "#F00");
            }
        }

        // çŠ¶æ€æ˜¾ç¤ºç¼“å­˜ï¼Œé¿å…é¢‘ç¹æ›´æ–°DOM
        let lastStatusText = '';
        let lastStatusColor = '';

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤ºï¼ˆå¸¦ç¼“å­˜ï¼Œåªåœ¨å˜åŒ–æ—¶æ›´æ–°ï¼‰
        function updateGestureStatus(text, color) {
            if (text !== lastStatusText || color !== lastStatusColor) {
                const statusDiv = document.getElementById('gesture-status');
                if (statusDiv) {
                    statusDiv.innerText = text;
                    statusDiv.style.color = color;
                }
                lastStatusText = text;
                lastStatusColor = color;
            }
        }

        function animate() {
            requestAnimationFrame(animate); controls.update(); const dt = clock.getDelta();

            // æ‰‹åŠ¿æ—‹è½¬æ§åˆ¶ - æ”¯æŒç›¸å¯¹ç§»åŠ¨æ—‹è½¬ï¼Œæ‰‹ç¦»å¼€åä¿æŒä½ç½®ï¼Œå¸¦å¹³æ»‘å’Œæ­»åŒº
            if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
                // å¯¹æ‰‹éƒ¨ä½ç½®è¿›è¡Œå¹³æ»‘å¤„ç†ï¼ˆä½é€šæ»¤æ³¢ï¼‰
                STATE.hand.smoothX += (STATE.hand.x - STATE.hand.smoothX) * GESTURE_CONFIG.smoothFactor;
                STATE.hand.smoothY += (STATE.hand.y - STATE.hand.smoothY) * GESTURE_CONFIG.smoothFactor;

                if (!STATE.hand.isGrabbing) {
                    // åˆšå¼€å§‹æ£€æµ‹åˆ°æ‰‹ï¼Œé‡ç½®å¹³æ»‘ä½ç½®å¹¶è®°å½•èµ·å§‹ä½ç½®
                    STATE.hand.isGrabbing = true;
                    STATE.hand.smoothX = STATE.hand.x;  // é‡ç½®å¹³æ»‘ä½ç½®ä¸ºå½“å‰ä½ç½®
                    STATE.hand.smoothY = STATE.hand.y;
                    STATE.hand.lastX = STATE.hand.x;
                    STATE.hand.lastY = STATE.hand.y;
                } else {
                    // è®¡ç®—å¹³æ»‘åæ‰‹çš„ç§»åŠ¨å¢é‡
                    const deltaX = STATE.hand.smoothX - STATE.hand.lastX;
                    const deltaY = STATE.hand.smoothY - STATE.hand.lastY;

                    // æ­»åŒºè¿‡æ»¤ - å¿½ç•¥å¾®å°æ™ƒåŠ¨
                    if (Math.abs(deltaX) > GESTURE_CONFIG.deadZone || Math.abs(deltaY) > GESTURE_CONFIG.deadZone) {
                        // æ ¹æ®å¢é‡è®¡ç®—ç›®æ ‡æ—‹è½¬è§’åº¦
                        STATE.rotation.targetY += deltaX * GESTURE_CONFIG.sensitivity * Math.PI;
                        STATE.rotation.targetX += deltaY * GESTURE_CONFIG.sensitivity * Math.PI * 0.3;

                        // é™åˆ¶ä¸Šä¸‹æ—‹è½¬è§’åº¦
                        STATE.rotation.targetX = Math.max(-0.5, Math.min(0.5, STATE.rotation.targetX));

                        // æ›´æ–°ä¸Šä¸€æ¬¡ä½ç½®
                        STATE.hand.lastX = STATE.hand.smoothX;
                        STATE.hand.lastY = STATE.hand.smoothY;
                    }
                }

                // å¹³æ»‘æ’å€¼åˆ°ç›®æ ‡æ—‹è½¬è§’åº¦
                STATE.rotation.y += (STATE.rotation.targetY - STATE.rotation.y) * GESTURE_CONFIG.rotationSmooth;
                STATE.rotation.x += (STATE.rotation.targetX - STATE.rotation.x) * GESTURE_CONFIG.rotationSmooth;

                mainGroup.rotation.y = STATE.rotation.y;
                mainGroup.rotation.x = STATE.rotation.x;
            } else if (STATE.mode === 'SCATTER' && !STATE.hand.detected) {
                // æ‰‹ç¦»å¼€åï¼Œç»§ç»­å¹³æ»‘åˆ°ç›®æ ‡ä½ç½®
                STATE.hand.isGrabbing = false;
                STATE.rotation.y += (STATE.rotation.targetY - STATE.rotation.y) * GESTURE_CONFIG.rotationSmooth;
                STATE.rotation.x += (STATE.rotation.targetX - STATE.rotation.x) * GESTURE_CONFIG.rotationSmooth;
                mainGroup.rotation.y = STATE.rotation.y;
                mainGroup.rotation.x = STATE.rotation.x;
            } else {
                // TREEæ¨¡å¼æˆ–å…¶ä»–æ¨¡å¼
                if (STATE.mode === 'TREE') {
                    STATE.hand.isGrabbing = false;
                    STATE.rotation.targetY += 0.3 * dt;
                    STATE.rotation.targetX += (0 - STATE.rotation.targetX) * 2.0 * dt;
                    STATE.rotation.y = STATE.rotation.targetY;
                    STATE.rotation.x = STATE.rotation.targetX;
                    mainGroup.rotation.y = STATE.rotation.y;
                    mainGroup.rotation.x = STATE.rotation.x;
                } else {
                    // FOCUSæ¨¡å¼ç­‰ï¼Œç¼“æ…¢æ—‹è½¬
                    STATE.rotation.targetY += 0.1 * dt;
                    STATE.rotation.y = STATE.rotation.targetY;
                    mainGroup.rotation.y = STATE.rotation.y;
                }
            }
            // æ›´æ–° InstancedMesh ç²’å­
            updateInstancedParticles(dt);

            // æ›´æ–°ç°å°˜ç²’å­
            updateDustParticles(dt);

            // æ›´æ–°é›ªèŠ±ç²’å­
            updateSnowParticles(dt);

            // æ›´æ–°ç…§ç‰‡ç²’å­ï¼ˆä¿æŒåŸæœ‰æ–¹å¼ï¼‰
            particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));

            composer.render();
        }

        // æ£€æŸ¥æ˜¯å¦é¦–æ¬¡è®¿é—®
        const VISITED_KEY = 'xmas_visited';
        const hasVisited = localStorage.getItem(VISITED_KEY);
        const loader = document.getElementById('loader');

        async function startApp() {
            // æ ‡è®°å·²è¿›å…¥é¡µé¢
            hasEnteredPage = true;

            // å¦‚æœæ¨¡å‹è¿˜åœ¨åŠ è½½ä¸­ï¼Œæ˜¾ç¤ºåŠ è½½æç¤ºå¹¶å¯åŠ¨å€’è®¡æ—¶
            const loadingTip = document.getElementById('gesture-loading-tip');
            if (loadingTip && !isModelPreloaded && !handLandmarker) {
                loadingTip.style.display = 'block';
                startGestureCountdown();
            }

            loader.classList.add('loading');

            await init();
            attemptPlay();

            // è®°å½•å·²è®¿é—®
            localStorage.setItem(VISITED_KEY, 'true');
        }

        if (hasVisited) {
            // éé¦–æ¬¡è®¿é—®ï¼Œç›´æ¥å¯åŠ¨ï¼ˆä¸æ˜¾ç¤º loaderï¼‰
            loader.classList.add('loading');
            loader.style.display = 'flex';
            init().then(() => attemptPlay());
        } else {
            // é¦–æ¬¡è®¿é—®ï¼Œæ˜¾ç¤ºè¿›å…¥é¡µé¢ï¼ŒåŒæ—¶åå°é¢„åŠ è½½æ‰‹åŠ¿æ¨¡å‹
            loader.style.display = 'flex';
            document.getElementById('enter-btn').addEventListener('click', startApp);
            // ç«‹å³å¼€å§‹é¢„åŠ è½½æ‰‹åŠ¿æ¨¡å‹
            preloadGestureModel();
        }
    </script>
</body>

</html>
